#==============================================================================
# Messaging.rogue
#==============================================================================

$module Plasmacore

$requisite Byte[].clear()
$requisite Byte[].reserve(Int32)

class MessageManager [requisite singleton]
  PROPERTIES
    receive_buffer      = Byte[]
    reader              = DataReader( receive_buffer )

    received_id_to_name = Table<<Int32,String>>()

    message = Message()
      # Recycled for all sent and received messages

  METHODS
    method init_object
      println "MessageManager init_object()"

    method update->Byte[] [requisite]
      # 'reader' has already been set up to decode 'receive_buffer', which 
      # in turn has already been filled with incoming message bytes by the
      # native layer.
      reader.reset( 0 )

      while (reader.has_another)
        message.init( reader )
println "$ x:$ y:$" (message.type,message.get_int32("x"),message.get_int32("y"))
      endWhile

      return null
endClass

class Message
  ENUMERATE
    DATA_TYPE_ID_DEFINITION = 0
    DATA_TYPE_ID            = 1
    DATA_TYPE_INT32         = 5

  PROPERTIES
    type    : String
    reader  = BufferedDataReader()
    buffer  = StringBuilder()
    keys    = String[]
    offsets = Int32[]

  METHODS
    method init
      
    method init( source:DataReader )
      local size = source.read_int32
      source.read( reader.buffer.clear, size )
      reader.reset( 0 )
      type = read_id
      while (index_another) noAction

    method index_another->Logical
      if (not reader.has_another) return false
      local key    = read_id
      local offset = reader.position
      keys.add( key )
      offsets.add( offset )

      # Skip value
      local data_type = reader.read_int32x
      which (data_type)
        case DATA_TYPE_ID_DEFINITION, DATA_TYPE_ID
          read_id

        case DATA_TYPE_INT32
          reader.read_int32x

        others
          print   "Message encoding error: "
          println "unsupported data type $." (data_type)
      endWhich
      return true

    method get_int32( name:String, default=0:Int32 )->Int32
      local i = keys.locate( name )
      if (not i.exists) return default

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_INT32
          return reader.read_int32x
      endWhich

      return default

    # INTERNAL USE
    method read_id->String
      local id_type = reader.read_int32x
      which (id_type)
        case DATA_TYPE_ID_DEFINITION
          local id = reader.read_int32x
          local name = MessageManager.received_id_to_name[ id ]
          if (name)
            reader.read_string( buffer.clear )  # skip the definition
          else
            name = reader.read_string( buffer.clear )->String
            MessageManager.received_id_to_name[ id ] = name
          endIf
          return name

        case DATA_TYPE_ID
          local id = reader.read_int32x
          local name = MessageManager.received_id_to_name[ id ]
          if (name) return name
          print   "Message encoding error: "
          println "undefined ID."

        others
          print   "Message encoding error: "
          println "ID expected."
      endWhich

      return "Undefined"

endClass

