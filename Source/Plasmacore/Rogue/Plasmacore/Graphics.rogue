module Plasmacore

class Graphics [singleton]
  GLOBAL PROPERTIES
    stack = Graphics[]

  PROPERTIES
    canvas            : Canvas
    named_textures    = Table<<String,Texture>>()  # textures created from a filename
    bitmap_textures   = Table<<Bitmap,Texture>>()  # textures created from Bitmaps

    size              : XY
    true_size         : XY
    background_color  : Color

    projection_transform : Matrix

    transform            : Matrix
    view_transform       = Matrix.identity : Matrix
    object_transform     = Matrix.identity : Matrix
    view_transforms      = Matrix[]
    object_transforms    = Matrix[]

    view_transform_modified       : Logical
    object_transform_modified     : Logical

    mode              = ProjectionMode()
    unit_z            : Real64


  METHODS
    method init( canvas )
      size = canvas.size
      true_size = size
      background_color = Color.BLACK

    method acquire_texture( name:String )->Texture
      local entry = named_textures.find( name )
      if (entry) return entry.value

      local texture = Texture( name )

      local filepath = Plasmacore.find_asset( name )
      named_textures[ name ] = texture

      if (filepath)
        Graphics.load_texture( texture, File(filepath) )
      else
        println "No such texture: " + texture.name
      endIf

      return texture

    method acquire_texture( bitmap:Bitmap )->Texture
      local entry = bitmap_textures.find( bitmap )
      if (entry)
        local texture = entry.value
        if (texture.version != bitmap.version)
          # Backing bitmap has changed; redefine the texture
          Graphics.define_texture( texture, bitmap )
          texture.version = bitmap.version
        endIf
        return texture
      endIf

      local texture = Texture( bitmap )
      bitmap_textures[ bitmap ] = texture

      Graphics.define_texture( texture, bitmap )
      texture.version = bitmap.version

      return texture

    method begin_draw( canvas )->this
      clear_transforms
      size = canvas.size
      mode = mode.configure( size )
      mode.activate
      return this

    method bounds->Box
      return Box( XY(0,0), size )

    method center->XY
      return (size/2).floor

    method clear->this
      # Override
      return this

    method clear( background_color )->this
      return clear

    method clear_transforms->this
      object_transforms.clear
      view_transforms.clear
      view_transform_modified = true
      object_transform_modified = true
      return this

    method define_texture( texture:Texture, bitmap:Bitmap )
      noAction

    method draw_solid_quad( pt1:XYZW, pt2:XYZW, pt3:XYZW, pt4:XYZW,
                            c1:Color, c2:Color, c3:Color, c4:Color,
                            render_mode:RenderMode, shader:Shader )
      noAction

    method draw_textured_quad( texture:Texture,
        pt1:XYZW, pt2:XYZW, pt3:XYZW, pt4:XYZW,
        c1:Color, c2:Color, c3:Color, c4:Color,
        uv1:XY, uv2:XY, uv3:XY, uv4:XY,
        shader:Shader, render_mode:RenderMode )

        #{
    method draw_textured_triangle( texture:Texture, shader:Shader, render_mode:RenderMode,
        pt1:XY, pt2:XY, pt3:XY, uv1:XY, uv2:XY, uv3:XY )
        }#

    method end_draw->this
      return this

    method height->Int32 [macro]
      this.size.y->Int32

    method fill( box:Box, color=Color.WHITE:Color )
      if ((color.argb & 0xFF000000) == 0xFF000000) fill( box, color, RenderMode.OPAQUE_SHAPE )
      else                                         fill( box, color, RenderMode.ALPHA_SHAPE )

    method fill( box:Box, color:Color, render_mode:RenderMode, shader=Shader.COLOR:Shader )
      fill( box, color, color, color, color, render_mode, shader )

    method fill( box:Box, c1:Color, c2:Color, c3:Color, c4:Color )
      if ((c1.argb & c2.argb & c3.argb & c4.argb & 0xFF000000) == 0xFF000000)
        fill( box, c1, c2, c3, c4, RenderMode.OPAQUE_SHAPE )
      else
        fill( box, c1, c2, c3, c4, RenderMode.ALPHA_SHAPE )
      endIf

    method fill( box:Box, c1:Color, c2:Color, c3:Color, c4:Color, render_mode:RenderMode, shader=Shader.COLOR:Shader )
      local xform = transform
      local z     = -unit_z
      local pt1   = xform * XYZ( box.position,             z )
      local pt2   = xform * XYZ( box.position+box.size.xv, z )
      local pt3   = xform * XYZ( box.position+box.size,    z )
      local pt4   = xform * XYZ( box.position+box.size.yv, z )
      draw_solid_quad( pt1, pt2, pt3, pt4, c1, c2, c3, c4, render_mode, shader )

    method flush
      render

    method is_ready->Logical
      # The default Graphics context returns false.  Valid renderer-specific
      # contexts override this to return true.
      return false

    method load_texture( texture:Texture, file:File )
      noAction

    method pop->Graphics
      if (stack.count) Graphics = stack.remove_last
      return Graphics

    method pop_object_transform( n=1:Int32 )->this
      forEach (1..n)
        if (object_transforms.count)
          object_transforms.remove_last
          object_transform_modified = true
        endIf
      endForEach
      return this

    method pop_view_transform( n=1:Int32 )->this
      forEach (1..n)
        if (view_transforms.count)
          view_transforms.remove_last
          view_transform_modified = true
        endIf
      endForEach
      return this

    method push( g:Graphics )->Graphics
      stack.add( this )
      Graphics = g
      return g

    method push_object_transform( m:Matrix )->this
      object_transforms.add( m )
      object_transform_modified = true
      return this

    method push_view_transform( m:Matrix )->this
      view_transforms.add( m )
      view_transform_modified = true
      return this

    method render

    method set_mode_2dx( size=Graphics.size, unit_z=384, max_z=16:Real64 )
      clear_transforms
      mode = mode.configure_2dx( size.x, size.y, unit_z, max_z )
      mode.activate

    method transform->Matrix
      update_transform
      return @transform

    method update_transform
      if (not (view_transform_modified or object_transform_modified)) return

      if (view_transform_modified)
        view_transform_modified = false
        if (view_transforms.count)
          view_transform = view_transforms.first
          forEach (i in 1..view_transforms.count-1)
            view_transform = view_transform * view_transforms[i]
          endForEach
        endIf
      endIf

      if (object_transform_modified)
        object_transform_modified = false
        if (object_transforms.count)
          object_transform = object_transforms.last
          forEach (i in object_transforms.count-2 downTo 0)
            object_transform = object_transform * object_transforms[i]
          endForEach
        endIf
      endIf

      if (view_transforms.count)
        if (object_transforms.count)
          transform = view_transform * object_transform
        else
          transform = view_transform
        endIf
      else
        if (object_transforms.count)
          transform = object_transform
        else
          transform = Matrix.identity
        endIf
      endIf

    method width->Int32 [macro]
      this.size.x->Int32
endClass

