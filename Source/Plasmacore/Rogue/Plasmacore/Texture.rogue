module Plasmacore

class Texture
  CLASS
    nativeHeader #include "Starbright.h"

  PROPERTIES
    id            : Int32    # id in loading display context
    image_size    : XY       # In pixels
    texture_size  : XY       # In pixels
    uv_size       : XY       # (1,1) in most cases
    is_opaque     : Logical

  GLOBAL METHODS
    method create( name:String )->Texture
      local texture = Display.textures_by_name[ name ]
      if (texture) return texture

      local filepath = Plasmacore.find_asset( name )
      if (filepath)
        texture = Texture( File(filepath) )
      else
        println "File not found: " + name
        texture = Texture( Bitmap(1,1,Color.WHITE) )
      endIf

      Display.textures_by_name[ name ] = texture
      return texture

  METHODS
    method init( file:File )->Texture
      nativeCode
        #include "ImageIO.h"
        using namespace ImageIO;
        #include "GGBitmap.h"
      endNativeCode

      local image_w : Int32
      local image_h : Int32
      local texture_w : Int32
      local texture_h : Int32

      native @|FILE* fp = fopen( (const char*)$file->filepath->utf8, "rb" );
              |if (fp)
              |{
              |  fseek( fp, 0, SEEK_END );
              |  int file_size = (int) ftell( fp );
              |  fseek( fp, 0, SEEK_SET );
              |  char* file_bytes = new char[ file_size ];
              |  fread( file_bytes, 1, file_size, fp );
              |
              |  Decoder decoder;
              |  if (decoder.open((Byte*)file_bytes,file_size))
              |  {
              |    $image_w = decoder.width;
              |    $image_h = decoder.height;
              |
              |    GG::Bitmap bitmap( 0, $image_w, $image_h, 32 );
              |    if (decoder.decode_argb32( (ARGB32*)bitmap.data ))
              |    {
              |      $is_opaque = true;
              |      ARGB32* data = (ARGB32*) bitmap.data;
              |      for (int i=$image_w*$image_h; --i>=0; )
              |      {
              |        if ((data[i] & 0xFF000000) != 0xFF000000)
              |        {
              |          $is_opaque = false;
              |          break;
              |        }
              |      }
              |      bitmap.filter( GG::FilterFn_premultiply_alpha );
              |      bitmap.expand_to_power_of_two();
              |      $texture_w = bitmap.width;
              |      $texture_h = bitmap.height;
              |      $id = Starbright::renderer->define_texture($id, (ARGB32*)bitmap.data, $texture_w, $texture_h, 32);
              |    }
              |  }
              |
              |  delete[] file_bytes;
              |  fclose( fp );
              |}

      if (id)
        image_size   = XY( image_w, image_h )
        texture_size = XY( texture_w, texture_h )
        uv_size      = image_size / texture_size
      endIf

      Display.texture_list.add( this )

    method init( bitmap:Bitmap )
      nativeCode
        #include "ImageIO.h"
        using namespace ImageIO;
        #include "GGBitmap.h"
      endNativeCode

      is_opaque = bitmap.is_opaque

      local image_w = bitmap.width
      local image_h = bitmap.height
      local texture_w, texture_h : Int32
      local bpp = 32

      native @|GG::Bitmap bitmap( $bitmap->pixels->data->bytes, $image_w, $image_h, $bpp );
              |bitmap.filter( GG::FilterFn_premultiply_alpha );
              |bitmap.expand_to_power_of_two();
              |$texture_w = bitmap.width;
              |$texture_h = bitmap.height;
              |$id = Starbright::renderer->define_texture( $id,
              |    (ARGB32*)bitmap.data, $texture_w, $texture_h, 32 );

      image_size   = XY( image_w, image_h )
      texture_size = XY( texture_w, texture_h )
      uv_size      = image_size / texture_size

      Display.texture_list.add( this )

    method image_height->Int32 [macro]
      this.image_size.y

    method image_width->Int32 [macro]
      this.image_size.x

    method texture_height->Int32 [macro]
      this.texture_size.y

    method texture_width->Int32 [macro]
      this.texture_size.x

    method uv_height->Real64 [macro]
      this.uv_size.y

    method uv_width->Real64 [macro]
      this.uv_size.x
endClass

