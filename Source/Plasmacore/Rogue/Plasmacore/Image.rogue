module Plasmacore

class Image
  PROPERTIES
    name        : String
    image_info  : Value    # all the info necessary to load the image
    data        : ImageData
    position    : XY
    z           = 1.0
    size        : XY
    scale       = XY(1,1)
    rotation    : Rotation
    shader      : Shader
    anchor      = Anchor.CENTER : Anchor
    render_mode : RenderMode
    colors      = Colors(Color.WHITE) : Colors

  METHODS
    method init( name )
      init( Plasmacore.image_info_lookup[ name ] )

    method init( image_info )

    method init( other:Image )
      data        = other.data
      position    = other.position
      z           = other.z
      size        = other.size
      scale       = other.scale
      rotation    = other.rotation
      shader      = other.shader
      anchor      = other.anchor
      render_mode = other.render_mode
      colors      = other.colors

    method init( data )

    method add( child:Image )->this
      data.add( child )
      return this

    method set_uv( subset:Box )
      data.set_uv( subset )

    method cloned->Image
      return Image( this )

    method collect_texture_names( texture_names:StringTable<<Logical>> )
      if (not image_info) return

      which (image_info.string("type"))
        case "TextureImage"
          texture_names[ image_info.string("texture") ] = true
      endWhich

    method draw
      load
      data.draw( this )

    method draw( position )
      load
      data.draw( this )

    method load
      if (data) return
      if (perform_load) return

      println "Error loading " + select{ name || image_info->String }
      data = ColorFillImageData()
      colors = Colors( Color.WHITE )
      render_mode = RenderMode.OPAQUE_SHAPE
      shader = ColorShader

    method perform_load->Logical
      if (not image_info) return false

      local image_type = image_info.string( "type" )
      which (image_type)
        case "TextureImage"
          local texture = Texture( image_info.string("texture") )
          data = TextureImageData( texture )
          local bounds = Box( image_info.table("uv") )
          size = bounds.size
          uv = bounds
          shader = TextureShader
          render_mode = select{ texture.is_opaque:RenderMode.OPAQUE_IMAGE || RenderMode.ALPHA_IMAGE }
          return true
      endWhich

      return false

    method set( bitmap:Bitmap )
      data = data.set( bitmap )
      size = bitmap.size

    method set_anchor( @anchor )->this
      return this

    method set_color( color:Color )->this
      colors = Colors( color )
      return this

    method set_color( color:Int32 )->this
      colors = Colors( color )
      return this

    method set_colors( @colors )->this
      return this

    method set_position( @position )->this
      return this

    method set_position( x:Real64, y:Real64 )->this
      @position = XY(x,y)
      return this

    method set_position( xyz:XYZ )->this
      @position = xyz->XY
      @z = xyz.z
      return this

    method set_position( x:Real64, y:Real64, _z:Real64 )->this
      @position = XY(x,y)
      @z = _z
      return this

    method set_render_mode( @render_mode )->this
      return this

    method set_rotation( @rotation )->this
      return this

    method set_scale( @scale )->this
      return this

    method set_scale( s:Real64 )->this
      @scale = XY(s,s)
      return this

    method set_shader( @shader )->this
      return this

    method set_size( @size )->this
      return this

    method set_z( @z )->this
      return this

    method tint( t:Real64 )->this
      # t=0.0: shader set to TEXTURE
      # t>0.0: shader set to TEXTURE_WITH_COLOR_FILL, color alpha set to t*255
      if (t == 0)
        shader = TextureShader
      else
        local a = Int32( t * 255 )
        colors.a = colors.a.with_alpha( a )
        colors.b = colors.b.with_alpha( a )
        colors.c = colors.c.with_alpha( a )
        colors.d = colors.d.with_alpha( a )
        shader = TextureShaderWithColorFill
      endIf

      return this
endClass

#{
class CompositeImage : Image
  METHODS
    method init( size )
      data = CompositeImageData()

    method init( w:Int32, h:Int32 )
      init( XY(w,h) )
endClass
}#

routine ColorFillImage( color:Color, size=Displays.size:XY )->Image
  local result = Image( ColorFillImageData() )
  result.colors = Colors( color )
  result.shader = ColorShader
  result.render_mode = select{ color.is_opaque:RenderMode.OPAQUE_SHAPE || RenderMode.ALPHA_SHAPE }
  return result
endRoutine

routine ColorFillImage( colors:Colors, size=Displays.size:XY )->Image
  local result = Image( ColorFillImageData() )
  result.colors = colors
  result.shader = ColorShader
  result.render_mode = select{ colors.is_opaque:RenderMode.OPAQUE_SHAPE || RenderMode.ALPHA_SHAPE }
  return result
endRoutine

routine TextureImage( texture:Texture )->Image
  local result = Image( TextureImageData(texture) )
  result.shader = TextureShader
  result.render_mode = select{ texture.is_opaque:RenderMode.OPAQUE_IMAGE || RenderMode.ALPHA_IMAGE }
  result.size = texture.image_size
  return result
endRoutine

routine TextureImage( bitmap:Bitmap )->Image
  return TextureImage( Texture(bitmap) )
endRoutine


class ImageData
  METHODS
    method add( child:Image )
      println "Illegal operation $.add(Image)." (type_name)

    method set_uv( subset:Box )
      noAction

    method draw( image:Image )

    method set( bitmap:Bitmap )->ImageData
      return TextureImageData( Texture(bitmap) )

endClass

class CompositeImageData : ImageData
  PROPERTIES
    images = Image[]

  METHODS
    method add( child:Image )
      images.add( child )

    method draw( image:Image )
      local size = image.size * image.scale
      local handle = XYZ( (image.anchor.position * size).floor, 0 )
      local z = -Display.unit_z * image.z

      local pos = image.position
      local has_rotation = not image.rotation.is_zero
      if (has_rotation)
        Display.push_view_transform( Quaternion(image.rotation).to_matrix( handle, XYZ(pos,z)) )
      else
        Display.push_view_transform( Matrix.translate(XYZ(pos,z)-handle) )
      endIf

      forEach (piece in images) piece.draw

      on_draw

      Display.pop_view_transform

    method on_draw

endClass

class ColorFillImageData : ImageData
  METHODS
    method draw( image:Image )
      local size = image.size * image.scale
      local handle = XYZ( (image.anchor.position * size).floor, 0 )
      local z = -Display.unit_z * image.z

      local pos = image.position
      local has_rotation = not image.rotation.is_zero
      if (has_rotation)
        Display.push_object_transform( Quaternion(image.rotation).to_matrix( handle, XYZ(pos,z)) )
      else
        Display.push_object_transform( Matrix.translate(XYZ(pos,z)-handle) )
      endIf

      local transform = Display.transform

      local w = size.x
      local h = size.y
      local corners = Corners<<XYZW>>(
        transform * XYZ( 0, 0, 0 ),
        transform * XYZ( w, 0, 0 ),
        transform * XYZ( w, h, 0 ),
        transform * XYZ( 0, h, 0 ) )

      Display.draw_solid_quad( corners, image.colors, image.render_mode, image.shader )

      Display.pop_object_transform

endClass

class TextureImageData : ImageData
  PROPERTIES
    texture : Texture
    uv1     : XY
    uv2     : XY

  METHODS
    method init( texture )
      uv2 = texture.uv_size

    method set_uv( subset:Box )
      uv1 = subset.top_left / texture.texture_size
      uv2 = subset.bottom_right / texture.texture_size

    method draw( image:Image )
      local size = image.size * image.scale
      local handle = XYZ( (image.anchor.position * size).floor, 0 )
      local z = -Display.unit_z * image.z

      local pos = image.position
      local has_rotation = not image.rotation.is_zero
      if (has_rotation)
        Display.push_object_transform( Quaternion(image.rotation).to_matrix( handle, XYZ(pos,z)) )
      else
        Display.push_object_transform( Matrix.translate(XYZ(pos,z)-handle) )
      endIf

      local transform = Display.transform

      local w = size.x
      local h = size.y
      local corners = Corners<<XYZW>>(
        transform * XYZ( 0, 0, 0 ),
        transform * XYZ( w, 0, 0 ),
        transform * XYZ( w, h, 0 ),
        transform * XYZ( 0, h, 0 ) )

      Display.draw_textured_quad( texture, corners, image.colors,
        Corners<<XY>>( uv1, XY(uv2.x,uv1.y), uv2, XY(uv1.x,uv2.y) ),
        image.render_mode, image.shader )

      Display.pop_object_transform

    method set( bitmap:Bitmap )->this
      texture.set( bitmap )
      return this
endClass

