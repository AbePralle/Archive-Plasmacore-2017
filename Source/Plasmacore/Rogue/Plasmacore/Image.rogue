module Plasmacore

class Image
  PROPERTIES
    data        : ImageData
    position    : XY
    z           = 1.0
    size        : XY
    scale       = XY(1,1)
    rotation    : Rotation
    shader      : Shader
    anchor      = Anchor.CENTER : Anchor
    render_mode : RenderMode
    color       = Color.WHITE : Color

  METHODS
    method init( size )
      data = CompositeImageData()

    method init( texture:Texture )
      data = TextureImageData( texture )
      shader = Shader.TEXTURE
      render_mode = select{ texture.is_opaque:RenderMode.OPAQUE_IMAGE || RenderMode.ALPHA_IMAGE }
      size = texture.image_size

    method init( color, size=Displays.size )
      data = SolidColorImageData( Colors(color) )
      shader = Shader.COLOR
      render_mode = select{ color.is_opaque:RenderMode.OPAQUE_SHAPE || RenderMode.ALPHA_SHAPE }

    method init( colors:Colors, size=Display.size )
      data = SolidColorImageData( colors )
      shader = Shader.COLOR
      render_mode = select{ colors.is_opaque:RenderMode.OPAQUE_SHAPE || RenderMode.ALPHA_SHAPE }

    method init( other:Image )
      data        = other.data
      position    = other.position
      z           = other.z
      size        = other.size
      scale       = other.scale
      rotation    = other.rotation
      shader      = other.shader
      anchor      = other.anchor
      render_mode = other.render_mode
      color       = other.color

    method init( bitmap:Bitmap )
      init( Texture(bitmap) )

    method add( child:Image )->this
      data.add( child )
      return this

    method adjust_subset( subset:Box )
      data.adjust_subset( subset )

    method clone->Image
      return Image( this )

    method draw
      data.draw( this )

    method draw( position )
      data.draw( this )

    method set( bitmap:Bitmap )
      data = data.set( bitmap )
      size = bitmap.size

    method set_anchor( @anchor )->this
      return this

    method set_color( @color )->this
      return this

    method set_position( @position )->this
      return this

    method set_position( x:Real64, y:Real64 )->this
      @position = XY(x,y)
      return this

    method set_position( xyz:XYZ )->this
      @position = xyz->XY
      @z = xyz.z
      return this

    method set_position( x:Real64, y:Real64, _z:Real64 )->this
      @position = XY(x,y)
      @z = _z
      return this

    method set_render_mode( @render_mode )->this
      return this

    method set_rotation( @rotation )->this
      return this

    method set_scale( @scale )->this
      return this

    method set_scale( s:Real64 )->this
      @scale = XY(s,s)
      return this

    method set_shader( @shader )->this
      return this

    method set_size( @size )->this
      return this

    method set_z( @z )->this
      return this
endClass

class ImageData
  METHODS
    method add( child:Image )
      println "Illegal operation $.add(Image)." (type_name)

    method adjust_subset( subset:Box )
      noAction

    method draw( image:Image )

    method set( bitmap:Bitmap )->ImageData
      return TextureImageData( Texture(bitmap) )

endClass

class CompositeImageData : ImageData
  PROPERTIES
    images = Image[]

  METHODS
    method add( child:Image )
      images.add( child )

    method draw( image:Image )
      local size = image.size * image.scale
      local handle = XYZ( (image.anchor.position * size).floor, 0 )
      local z = -Display.unit_z * image.z

      local pos = image.position
      local has_rotation = not image.rotation.is_zero
      if (has_rotation)
        Display.push_view_transform( Quaternion(image.rotation).to_matrix( handle, XYZ(pos,z)) )
      else
        Display.push_view_transform( Matrix.translate(XYZ(pos,z)-handle) )
      endIf

      forEach (img in images) img.draw

      #{
      local transform = Display.transform
      local w = size.x
      local h = size.y
      local corners = Corners<<XYZW>>(
        transform * XYZ( 0, 0, 0 ),
        transform * XYZ( w, 0, 0 ),
        transform * XYZ( w, h, 0 ),
        transform * XYZ( 0, h, 0 ) )
      Display.draw_solid_quad( corners,
        Colors(Color.WHITE), RenderMode.OPAQUE_SHAPE, Shader.COLOR )
      }#

      Display.pop_view_transform

endClass

class SolidColorImageData : ImageData
  PROPERTIES
    colors : Colors

  METHODS
    method init( colors )

    method draw( image:Image )
      local size = image.size * image.scale
      local handle = XYZ( (image.anchor.position * size).floor, 0 )
      local z = -Display.unit_z * image.z

      local pos = image.position
      local has_rotation = not image.rotation.is_zero
      if (has_rotation)
        Display.push_object_transform( Quaternion(image.rotation).to_matrix( handle, XYZ(pos,z)) )
      else
        Display.push_object_transform( Matrix.translate(XYZ(pos,z)-handle) )
      endIf

      local transform = Display.transform

      local w = size.x
      local h = size.y
      local corners = Corners<<XYZW>>(
        transform * XYZ( 0, 0, 0 ),
        transform * XYZ( w, 0, 0 ),
        transform * XYZ( w, h, 0 ),
        transform * XYZ( 0, h, 0 ) )

      Display.draw_solid_quad( corners, colors, image.render_mode, image.shader )

      Display.pop_object_transform

endClass

class TextureImageData : ImageData
  PROPERTIES
    texture : Texture
    uv1     : XY
    uv2     : XY

  METHODS
    method init( texture )
      uv2 = texture.uv_size

    method adjust_subset( subset:Box )
      uv1 = subset.top_left / texture.texture_size
      uv2 = subset.bottom_right / texture.texture_size

    method draw( image:Image )
      local size = image.size * image.scale
      local handle = XYZ( (image.anchor.position * size).floor, 0 )
      local z = -Display.unit_z * image.z

      local pos = image.position
      local has_rotation = not image.rotation.is_zero
      if (has_rotation)
        Display.push_object_transform( Quaternion(image.rotation).to_matrix( handle, XYZ(pos,z)) )
      else
        Display.push_object_transform( Matrix.translate(XYZ(pos,z)-handle) )
      endIf

      local transform = Display.transform

      local w = size.x
      local h = size.y
      local corners = Corners<<XYZW>>(
        transform * XYZ( 0, 0, 0 ),
        transform * XYZ( w, 0, 0 ),
        transform * XYZ( w, h, 0 ),
        transform * XYZ( 0, h, 0 ) )

      Display.draw_textured_quad( texture, corners, Colors(image.color),
        Corners<<XY>>( uv1, XY(uv2.x,uv1.y), uv2, XY(uv1.x,uv2.y) ),
        image.render_mode, image.shader )

      Display.pop_object_transform

    method set( bitmap:Bitmap )->this
      texture.set( bitmap )
      return this
endClass

