module Plasmacore

nativeCode
double rotation_degrees = 0.0;
endNativeCode


class StarbrightGraphics : Graphics
  CLASS
    nativeHeader #include "Starbright.h"

  METHODS
    method init( canvas )
      @trace

    method clear->this
      native @|Starbright::renderer->clear_color = $this->background_color;
              |Starbright::renderer->clear( Starbright::Renderer::CLEAR_COLOR );
      return this

    method define_texture( texture:Texture, bitmap:Bitmap )
      nativeCode
        #include "ImageIO.h"
        using namespace ImageIO;
        #include "GGBitmap.h"
      endNativeCode

      local image_w = bitmap.width
      local image_h = bitmap.height
      local texture_w, texture_h : Int32
      local bpp = 32

      native @|GG::Bitmap bitmap( $bitmap->pixels->data->bytes, $image_w, $image_h, $bpp );
              |bitmap.expand_to_power_of_two();
              |$texture_w = bitmap.width;
              |$texture_h = bitmap.height;
              |if ($texture->id)
              |{
              |  Starbright::renderer->update_texture( $texture->id, (ARGB32*)bitmap.data, $texture_w, $texture_h, 32 );
              |}
              |else
              |{
              |  $texture->id = Starbright::renderer->define_texture( (ARGB32*)bitmap.data, $texture_w, $texture_h, 32 );
              |}

      texture.image_size   = XY( image_w, image_h )
      texture.texture_size = XY( texture_w, texture_h )
      texture.uv_size      = texture.image_size / texture.texture_size

    method draw_textured_quad( texture:Texture, shader:Shader, render_mode:RenderMode,
        pt1:XYZ, pt2:XYZ, pt3:XYZ, pt4:XYZ, uv1:XY, uv2:XY, uv3:XY, uv4:XY )

      update_transform

      native @|Starbright::renderer->set_texture( 0, $texture->id );
              |Starbright::renderer->set_shader( $shader.id );
              |Starbright::renderer->set_primitive_type( Starbright::Renderer::TRIANGLES );
              |Starbright::renderer->set_render_mode( $render_mode.value );
              |Starbright::Vertex* v = Starbright::renderer->add_vertices( 6 );
              |
              |v[0].x = $pt1.x;
              |v[0].y = $pt1.y;
              |v[0].z = $pt1.z;
              |v[1].x = $pt2.x;
              |v[1].y = $pt2.y;
              |v[1].z = $pt2.z;
              |v[2].x = $pt3.x;
              |v[2].y = $pt3.y;
              |v[2].z = $pt3.z;
              |v[3].x = $pt1.x;
              |v[3].y = $pt1.y;
              |v[3].z = $pt1.z;
              |v[4].x = $pt3.x;
              |v[4].y = $pt3.y;
              |v[4].z = $pt3.z;
              |v[5].x = $pt4.x;
              |v[5].y = $pt4.y;
              |v[5].z = $pt4.z;
              |
              |v[0].u = $uv1.x;
              |v[0].v = $uv1.y;
              |v[1].u = $uv2.x;
              |v[1].v = $uv2.y;
              |v[2].u = $uv3.x;
              |v[2].v = $uv3.y;
              |v[3].u = $uv1.x;
              |v[3].v = $uv1.y;
              |v[4].u = $uv3.x;
              |v[4].v = $uv3.y;
              |v[5].u = $uv4.x;
              |v[5].v = $uv4.y;


    method draw_textured_triangle( texture:Texture, shader:Shader, render_mode:RenderMode,
        pt1:XY, pt2:XY, pt3:XY, uv1:XY, uv2:XY, uv3:XY )

      update_transform

      native @|Starbright::renderer->set_texture( 0, $texture->id );
              |Starbright::renderer->set_shader( $shader.id );
              |Starbright::renderer->set_primitive_type( Starbright::Renderer::TRIANGLES );
              |Starbright::renderer->set_render_mode( $render_mode.value );
              |Starbright::Vertex* v = Starbright::renderer->add_vertices( 3 );
              |v[0].x = $pt1.x;
              |v[0].y = $pt1.y;
              |v[0].u = $uv1.x;
              |v[0].v = $uv1.y;
              |v[1].x = $pt2.x;
              |v[1].y = $pt2.y;
              |v[1].u = $uv2.x;
              |v[1].v = $uv2.y;
              |v[2].x = $pt3.x;
              |v[2].y = $pt3.y;
              |v[2].u = $uv3.x;
              |v[2].v = $uv3.y;

    method is_ready->Logical
      return true

    method load_texture( texture:Texture, file:File )
      nativeCode
        #include "ImageIO.h"
        using namespace ImageIO;
        #include "GGBitmap.h"
      endNativeCode


      local id = 0
      local image_w : Int32
      local image_h : Int32
      local texture_w : Int32
      local texture_h : Int32

      native @|FILE* fp = fopen( (const char*)$file->filepath->utf8, "rb" );
              |if (fp)
              |{
              |  fseek( fp, 0, SEEK_END );
              |  int file_size = (int) ftell( fp );
              |  fseek( fp, 0, SEEK_SET );
              |  char* file_bytes = new char[ file_size ];
              |  fread( file_bytes, 1, file_size, fp );
              |
              |  Decoder decoder;
              |  if (decoder.open((Byte*)file_bytes,file_size))
              |  {
              |    $image_w = decoder.width;
              |    $image_h = decoder.height;
              |
              |    GG::Bitmap bitmap( 0, $image_w, $image_h, 32 );
              |    if (decoder.decode_argb32( (ARGB32*)bitmap.data ))
              |    {
              |      bitmap.expand_to_power_of_two();
              |      $texture_w = bitmap.width;
              |      $texture_h = bitmap.height;
              |      $id = Starbright::renderer->define_texture( (ARGB32*)bitmap.data, $texture_w, $texture_h, 32 );
              |    }
              |  }
              |
              |  delete[] file_bytes;
              |  fclose( fp );
              |}

      if (id)
        texture.id           = id
        texture.image_size   = XY( image_w, image_h )
        texture.texture_size = XY( texture_w, texture_h )
        texture.uv_size      = texture.image_size / texture.texture_size
      endIf

    method update_transform
      prior.update_transform
      native "Starbright::renderer->set_transform( &$this->transform.r1c1 );"

endClass

