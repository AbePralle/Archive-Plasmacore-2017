module Plasmacore

class StarbrightGraphics : Graphics
  CLASS
    nativeHeader #include "Starbright.h"

  METHODS
    method init( canvas )
      @trace

    method clear->this
      native @|Starbright::renderer->clear_color = $this->background_color.argb;
              |Starbright::renderer->clear( Starbright::Renderer::CLEAR_COLOR );
      return this

    method define_texture( texture:Texture, bitmap:Bitmap )
      nativeCode
        #include "ImageIO.h"
        using namespace ImageIO;
        #include "GGBitmap.h"
      endNativeCode

      local image_w = bitmap.width
      local image_h = bitmap.height
      local texture_w, texture_h : Int32
      local bpp = 32

      native @|GG::Bitmap bitmap( $bitmap->pixels->data->bytes, $image_w, $image_h, $bpp );
              |bitmap.filter( GG::FilterFn_premultiply_alpha );
              |bitmap.expand_to_power_of_two();
              |$texture_w = bitmap.width;
              |$texture_h = bitmap.height;
              |$texture->id = Starbright::renderer->define_texture( $texture->id,
              |    (ARGB32*)bitmap.data, $texture_w, $texture_h, 32 );

      texture.image_size   = XY( image_w, image_h )
      texture.texture_size = XY( texture_w, texture_h )
      texture.uv_size      = texture.image_size / texture.texture_size

    method draw_textured_quad( texture:Texture,
        corners:Corners<<XYZW>>,
        colors:Colors,
        uv1:XY, uv2:XY, uv3:XY, uv4:XY,
        shader:Shader, render_mode:RenderMode )

      native @|Starbright::renderer->set_texture( 0, $texture->id );
              |Starbright::renderer->set_shader( $shader.id );
              |Starbright::renderer->set_primitive_type( Starbright::Renderer::TRIANGLES );
              |Starbright::renderer->set_render_mode( $render_mode.value );
              |Starbright::Vertex* v = Starbright::renderer->add_vertices( 6 );
              |
              |v[0].x = $corners.a.x;
              |v[0].y = $corners.a.y;
              |v[0].z = $corners.a.z;
              |v[0].w = $corners.a.w;
              |v[1].x = $corners.b.x;
              |v[1].y = $corners.b.y;
              |v[1].z = $corners.b.z;
              |v[1].w = $corners.b.w;
              |v[2].x = $corners.c.x;
              |v[2].y = $corners.c.y;
              |v[2].z = $corners.c.z;
              |v[2].w = $corners.c.w;
              |v[3].x = $corners.a.x;
              |v[3].y = $corners.a.y;
              |v[3].z = $corners.a.z;
              |v[3].w = $corners.a.w;
              |v[4].x = $corners.c.x;
              |v[4].y = $corners.c.y;
              |v[4].z = $corners.c.z;
              |v[4].w = $corners.c.w;
              |v[5].x = $corners.d.x;
              |v[5].y = $corners.d.y;
              |v[5].z = $corners.d.z;
              |v[5].w = $corners.d.w;
              |
              |v[0].u = $uv1.x;
              |v[0].v = $uv1.y;
              |v[1].u = $uv2.x;
              |v[1].v = $uv2.y;
              |v[2].u = $uv3.x;
              |v[2].v = $uv3.y;
              |v[3].u = $uv1.x;
              |v[3].v = $uv1.y;
              |v[4].u = $uv3.x;
              |v[4].v = $uv3.y;
              |v[5].u = $uv4.x;
              |v[5].v = $uv4.y;
              |
              |v[0].color = $colors.a.argb;
              |v[0].color = $colors.a.argb;
              |v[1].color = $colors.b.argb;
              |v[1].color = $colors.b.argb;
              |v[2].color = $colors.c.argb;
              |v[2].color = $colors.c.argb;
              |v[3].color = $colors.a.argb;
              |v[3].color = $colors.a.argb;
              |v[4].color = $colors.c.argb;
              |v[4].color = $colors.c.argb;
              |v[5].color = $colors.d.argb;
              |v[5].color = $colors.d.argb;


    method draw_solid_quad( corners:Corners<<XYZW>>, colors:Colors, render_mode:RenderMode, shader:Shader )
      native @|Starbright::renderer->set_shader( $shader.id );
              |Starbright::renderer->set_primitive_type( Starbright::Renderer::TRIANGLES );
              |Starbright::renderer->set_render_mode( $render_mode.value );
              |Starbright::Vertex* v = Starbright::renderer->add_vertices( 6 );
              |
              |v[0].x = $corners.a.x;
              |v[0].y = $corners.a.y;
              |v[0].z = $corners.a.z;
              |v[0].w = $corners.a.w;
              |v[1].x = $corners.b.x;
              |v[1].y = $corners.b.y;
              |v[1].z = $corners.b.z;
              |v[1].w = $corners.b.w;
              |v[2].x = $corners.c.x;
              |v[2].y = $corners.c.y;
              |v[2].z = $corners.c.z;
              |v[2].w = $corners.c.w;
              |v[3].x = $corners.a.x;
              |v[3].y = $corners.a.y;
              |v[3].z = $corners.a.z;
              |v[3].w = $corners.a.w;
              |v[4].x = $corners.c.x;
              |v[4].y = $corners.c.y;
              |v[4].z = $corners.c.z;
              |v[4].w = $corners.c.w;
              |v[5].x = $corners.d.x;
              |v[5].y = $corners.d.y;
              |v[5].z = $corners.d.z;
              |v[5].w = $corners.d.w;
              |
              |v[0].color = $colors.a.argb;
              |v[0].color = $colors.a.argb;
              |v[1].color = $colors.b.argb;
              |v[1].color = $colors.b.argb;
              |v[2].color = $colors.c.argb;
              |v[2].color = $colors.c.argb;
              |v[3].color = $colors.a.argb;
              |v[3].color = $colors.a.argb;
              |v[4].color = $colors.c.argb;
              |v[4].color = $colors.c.argb;
              |v[5].color = $colors.d.argb;
              |v[5].color = $colors.d.argb;

    method flush
      native @|Starbright::renderer->flush();

    method is_ready->Logical
      return true

    method load_texture( texture:Texture, file:File )
      nativeCode
        #include "ImageIO.h"
        using namespace ImageIO;
        #include "GGBitmap.h"
      endNativeCode


      local id = texture.id  # may well be 0 (uninitialized)
      local image_w : Int32
      local image_h : Int32
      local texture_w : Int32
      local texture_h : Int32

      native @|FILE* fp = fopen( (const char*)$file->filepath->utf8, "rb" );
              |if (fp)
              |{
              |  fseek( fp, 0, SEEK_END );
              |  int file_size = (int) ftell( fp );
              |  fseek( fp, 0, SEEK_SET );
              |  char* file_bytes = new char[ file_size ];
              |  fread( file_bytes, 1, file_size, fp );
              |
              |  Decoder decoder;
              |  if (decoder.open((Byte*)file_bytes,file_size))
              |  {
              |    $image_w = decoder.width;
              |    $image_h = decoder.height;
              |
              |    GG::Bitmap bitmap( 0, $image_w, $image_h, 32 );
              |    if (decoder.decode_argb32( (ARGB32*)bitmap.data ))
              |    {
              |      bitmap.filter( GG::FilterFn_premultiply_alpha );
              |      bitmap.expand_to_power_of_two();
              |      $texture_w = bitmap.width;
              |      $texture_h = bitmap.height;
              |      $id = Starbright::renderer->define_texture($id, (ARGB32*)bitmap.data, $texture_w, $texture_h, 32);
              |    }
              |  }
              |
              |  delete[] file_bytes;
              |  fclose( fp );
              |}

      if (id)
        texture.id           = id
        texture.image_size   = XY( image_w, image_h )
        texture.texture_size = XY( texture_w, texture_h )
        texture.uv_size      = texture.image_size / texture.texture_size
      endIf

    method render
      native @|Starbright::renderer->render();

    method update_transform
      prior.update_transform
      native "Starbright::renderer->set_transform( &$this->projection_transform.r1c1 );"

endClass

