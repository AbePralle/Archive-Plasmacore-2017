module Plasmacore

class Bitmap
  PROPERTIES
    size   : XY
    pixels : Int32[]
    error  : Logical

  METHODS
    method init( size, color=Color.BLACK:Int32 ) [requisite]
      pixels = Int32[]( width*height, color )

    method init( x:Int32, y:Int32, color=Color.BLACK:Int32 ) [requisite]
      init( XY(x,y), color )

    method init( file:File )
      if (file and file.filepath)
        init( file.load_as_bytes )
      else
        if (not file)
          println "Attempting to load Bitmap with null file reference."
        else
          println "Attempting to load Bitmap with null filepath."
        endIf
        init( XY(1,1) )
        error = true
      endIf

    method init( bytes:Byte[] )
      if (not decode(bytes))
        init( XY(1,1) )
        error = true
      endIf

    method init( existing:Bitmap, bounds:Box )
      init( bounds.size )
      existing.draw( -bounds.position, this )

    method clear( color=Color.BLACK:Int32 )
      forEach (i of pixels) pixels[i] = color

    method include_native_code
      nativeCode
        #include "ImageIO.h"
        using namespace ImageIO;
      endNativeCode

    method decode( bytes:Byte[] )->Logical
      include_native_code
      native @|Decoder decoder;
              |if ( !decoder.open($bytes->data->bytes, $bytes->count) ) return 0;

      size = XY( native("decoder.width")->Int32, native("decoder.height")->Int32 )
      pixels = Int32[]( width * height )

      native @|if ( !decoder.decode_argb32((ARGB32*)$this->pixels->data->integers) ) return 0;
      return true

    method draw( pos:XY, dest_bitmap:Bitmap )
      local dest_width = dest_bitmap.width
      local x1 = pos.x : Int32
      local y1 = pos.y : Int32
      local x_limit = x1 + width : Int32
      local y_limit = y1 + height : Int32
      local i1 = 0
      local j1 = 0
      if (x1 < 0) i1 -= x1; x1 = 0
      if (y1 < 0) j1 -= y1; y1 = 0
      if (x_limit > dest_width)  x_limit = dest_width
      if (y_limit > dest_bitmap.height) y_limit = dest_bitmap.height
      if (x1 >= x_limit or y1 >= y_limit) return
      local x2 = x_limit - 1
      local y2 = y_limit - 1

      local w = x_limit - x1
      local src_width = width

      local src = j1 * width + i1 : Int32
      local dest = y1 * dest_width + x1 : Int32
      local src_pixels = pixels.data
      local dest_pixels = dest_bitmap.pixels.data
      forEach (y1..y2)
        dest_pixels.set( dest, src_pixels, src, w )
        src  += src_width
        dest += dest_width
      endForEach

    method get( x:Int32, y:Int32 )->Int32
      return pixels[ y*width + x ]

    method height->Int32 [macro]
      this.size.y->Int32

    method reframe( new_width:Int32, new_height:Int32, anchor=Anchor.TOP_LEFT:Anchor )
      if (width == new_width and height == new_height) return

      local bounds = Box(this.size).positioned_within( Box(new_width,new_height), anchor )
      local reframed = Bitmap( bounds.size )
      draw( bounds.position, reframed )

      this.size = reframed.size
      this.pixels = reframed.pixels

    method save_as_png( file:File )->Logical
      return file.save( to_png_bytes )

    method save_as_jpeg( file:File, quality=75:Int32 )->Logical
      return file.save( to_jpeg_bytes(quality) )

    method set( x:Int32, y:Int32, color:Int32 )->this
      pixels[ y*width + x ] = color
      return this

    method to_png_bytes->Byte[]
      include_native_code
      local w = width
      local h = height
      local count : Int32
      native @|Encoder encoder;
              |encoder.encode_argb32_png( (ARGB32*) $this->pixels->data->integers, $w, $h );
              |$count = (RogueInt32) encoder.encoded_byte_count;

      local bytes = Byte[]( count );
      bytes.count = count
      native @|memcpy( $bytes->data->bytes, encoder.encoded_bytes, $count );

      return bytes

    method to_jpeg_bytes( quality=75:Int32 )->Byte[]
      include_native_code
      local w = width
      local h = height
      local count : Int32
      native @|Encoder encoder;
              |encoder.quality = $quality;
              |encoder.encode_argb32_jpeg( (ARGB32*) $this->pixels->data->integers, $w, $h );
              |$count = (RogueInt32) encoder.encoded_byte_count;

      local bytes = Byte[]( count );
      bytes.count = count
      native @|memcpy( $bytes->data->bytes, encoder.encoded_bytes, $count );

      return bytes

    method width->Int32 [macro]
      this.size.x->Int32
endClass


