module Plasmacore

class Bitmap
  CLASS
    nativeCode
      #include "ImageIO.h"
      using namespace ImageIO;
      #include "GGBitmap.h"
    endNativeCode

  PROPERTIES
    size    : XY
    pixels  : Int32[]
    error   : Logical
    version : Int32  # A counter that is sometimes used to sync textures with this bitmap

  METHODS
    method init( size, color=Color.BLACK:Int32 ) [requisite]
      init( size, Int32[]( width*height, color ) )

    method init( x:Int32, y:Int32, color=Color.BLACK:Int32 ) [requisite]
      init( XY(x,y), color )

    method init( file:File )
      if (file and file.filepath)
        init( file.load_as_bytes )
      else
        if (not file)
          println "Attempting to load Bitmap with null file reference."
        else
          println "Attempting to load Bitmap with null filepath."
        endIf
        init( XY(1,1) )
        error = true
      endIf

    method init( bytes:Byte[] )
      if (not decode(bytes))
        init( XY(1,1) )
        error = true
      endIf

    method init( size, pixels )
      size = size.floor

    method init( x:Int32, y:Int32, pixels )
      init( XY(x,y), pixels )

    method init( existing:Bitmap, bounds:Box )
      init( bounds.size )
      existing.blit( this, -bounds.position )

    method clone->Bitmap
      local result = Bitmap( size, pixels.clone )
      result.error = this.error
      return result

    method add_rows( rows:Int32, color=0:Int32 )->this
      pixels.reserve( width*rows )
      forEach (1..width*rows) pixels.add( color )
      size += XY( 0, rows )
      return this

    method blit( dest_bitmap:Bitmap, pos:XY )
      blit( Box(0,0,size), dest_bitmap, pos )

    method blit( bounds:Box, dest_bitmap:Bitmap, dest_position:XY )
      native @|GG::Bitmap src( $this->pixels->data->bytes, (int)$this->size.x, (int)$this->size.y, 32 );
              |GG::Bitmap dest( $dest_bitmap->pixels->data->bytes, (int)$dest_bitmap->size.x, (int)$dest_bitmap->size.y, 32 );
              |src.blit_area( $bounds.position.x, $bounds.position.y, $bounds.size.x, $bounds.size.y,
              |               &dest, $dest_position.x, $dest_position.y );

    method clear( color=Color.BLACK:Int32 )
      forEach (i of pixels) pixels[i] = color

    method extend_edges( bounds:Box )
      local x1 = bounds.position.x
      local y1 = bounds.position.y
      local w  = bounds.size.x
      local h  = bounds.size.y
      local x2 = x1 + (w - 1)
      local y2 = y1 + (h - 1)
      blit( Box(x1,y1,w,1), this, XY(x1,y1-1) )  # top
      blit( Box(x1,y2,w,1), this, XY(x1,y2+1) )  # bottom
      blit( Box(x1,y1-1,1,h+2), this, XY(x1-1,y1-1) )  # left
      blit( Box(x2,y1-1,1,h+2), this, XY(x2+1,y1-1) )  # right

    method fill( box:Box, color:Int32 )
      local x = box.position.x
      local y = box.position.y
      local w = box.size.x
      local h = box.size.y
      native @|GG::Bitmap bitmap( $this->pixels->data->bytes, (int)$this->size.x, (int)$this->size.y, 32 );
              |bitmap.draw_border( $x, $y, $w, $h, (int)$color );

    method decode( bytes:Byte[] )->Logical
      native @|Decoder decoder;
              |if ( !decoder.open($bytes->data->bytes, $bytes->count) ) return 0;

      size = XY( native("decoder.width")->Int32, native("decoder.height")->Int32 )
      pixels = Int32[]( width * height )
      pixels.count = width * height

      native @|if ( !decoder.decode_argb32((ARGB32*)$this->pixels->data->integers) ) return 0;
      return true

    method get( x:Int32, y:Int32 )->Int32
      return pixels[ y*width + x ]

    method height->Int32 [macro]
      this.size.y->Int32

    method reframe( new_width:Int32, new_height:Int32, anchor=Anchor.TOP_LEFT:Anchor )
      if (width == new_width and height == new_height) return

      local bounds = Box(this.size).positioned_within( Box(new_width,new_height), anchor )
      local reframed = Bitmap( bounds.size )
      blit( reframed, bounds.position )

      this.size = reframed.size
      this.pixels = reframed.pixels

    method resize( new_width:Int32, new_height:Int32 )->this
      return resize( XY(new_width,new_height) )

    method resize( new_size:XY )->this
      local result = resized( new_size )
      size = result.size
      pixels = result.pixels
      error = result.error
      version = result.version
      return this

    method resize_to( other:Bitmap )
      native @|GG::Bitmap src( $this->pixels->data->bytes, (int)$this->size.x, (int)$this->size.y, 32 );
              |GG::Bitmap dest( $other->pixels->data->bytes, (int)$other->size.x, (int)$other->size.y, 32 );
              |src.resize_to( &dest );

    method resized( new_width:Int32, new_height:Int32 )->Bitmap
      return resized( XY(new_width,new_height) )

    method resized( new_size:XY )->Bitmap
      local result = Bitmap( new_size )
      resize_to( result )
      return result

    method save_as_png( file:File )->Logical
      return file.save( to_png_bytes )

    method save_as_jpeg( file:File, quality=75:Int32 )->Logical
      return file.save( to_jpeg_bytes(quality) )

    method set( x:Int32, y:Int32, color:Int32 )->this
      pixels[ y*width + x ] = color
      return this

    method to_png_bytes->Byte[]
      local w = width
      local h = height
      local count : Int32
      native @|Encoder encoder;
              |encoder.encode_argb32_png( (ARGB32*) $this->pixels->data->integers, $w, $h );
              |$count = (RogueInt32) encoder.encoded_byte_count;

      local bytes = Byte[]( count );
      bytes.count = count
      native @|memcpy( $bytes->data->bytes, encoder.encoded_bytes, $count );

      return bytes

    method to_jpeg_bytes( quality=75:Int32 )->Byte[]
      local w = width
      local h = height
      local count : Int32
      native @|Encoder encoder;
              |encoder.quality = $quality;
              |encoder.encode_argb32_jpeg( (ARGB32*) $this->pixels->data->integers, $w, $h );
              |$count = (RogueInt32) encoder.encoded_byte_count;

      local bytes = Byte[]( count );
      bytes.count = count
      native @|memcpy( $bytes->data->bytes, encoder.encoded_bytes, $count );

      return bytes

    method width->Int32 [macro]
      this.size.x->Int32
endClass


