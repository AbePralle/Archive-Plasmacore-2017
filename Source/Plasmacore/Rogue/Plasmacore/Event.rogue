module Plasmacore

class Event
  PROPERTIES
    is_consumed : Logical

  METHODS
    method consume
      this.is_consumed = true
endClass

class DrawEvent : Event [singleton]
  METHODS
    method init
      is_consumed = false
endClass

class UpdateEvent : Event [singleton]
  METHODS
    method init
      is_consumed = false
endClass

class KeyEvent : Event [singleton]
  PROPERTIES
    keycode     : Int32
    unicode     : Character
    syscode     : Int32
    is_press    : Logical
    is_repeat   : Logical

  METHODS
    method init( keycode, unicode, syscode, is_press=false, is_repeat=false )
      is_consumed = false  # Need to be explicit because KeyEvent is recycled.

    method character->Character [macro]
      this.unicode->Character

    method is_character( ch:Character )->Logical [macro]
      (this.unicode == ch)

    method is_press( ch:Character )->Logical
      return unicode == ch and is_press

    method is_repeat( ch:Character )->Logical
      return unicode == ch and is_repeat

    method is_release->Logical [macro]
      not this.is_press

    method is_release( ch:Character )->Logical
      return unicode == ch and not is_press

    method to->String
      local buffer = StringBuilder()
       which (unicode)
         case    1: buffer.print( "[LeftArrow] " )
         case    2: buffer.print( "[UpArrow] " )
         case    3: buffer.print( "[RightArrow] " )
         case    4: buffer.print( "[DownArrow] " )
         case    8: buffer.print( "[Backspace] " )
         case '\t': buffer.print( "[Tab] " )
         case '\n': buffer.print( "[Enter] " )
         case   27: buffer.print( "[Escape] " )
         case   32: buffer.print( "[Space] " )
         case  127: buffer.print( "[Delete] " )
         others
           if (unicode >= 32 and unicode != 127)
             buffer.print( "'" ).print( unicode ).print( "' " )
           endIf
           if (unicode < 32 or unicode == 127) buffer.print( "(Unicode " ).print( Int32(unicode) ).print( ") " )
       endWhich

       if (is_press)
         if (is_repeat) buffer.print( "pressed (repeating)" )
         else           buffer.print( "pressed" )
       else
         buffer.print( "released" )
       endIf

        if (is_consumed) buffer.print( " (consumed)" )

       return buffer->String

endClass


class PointerEvent : Event [singleton]
  ENUMERATE
    MOVEMENT = 0
    PRESS    = 1
    RELEASE  = 2
    SCROLL   = 3

  PROPERTIES
    type        : Int32
    position    : XY
    delta       : XY
    button      : Int32
    id          : Int32

  METHODS
    method init( type, position, delta, button, id )
      is_consumed = false  # Need to be explicit because PointerEvent is recycled.

    method is_movement->Logical [macro]
      (this.type == PointerEvent.MOVEMENT)

    method is_press->Logical [macro]
      (this.type == PointerEvent.PRESS)

    method is_press( button_index:Int32 )->Logical
      return (this.type == PRESS and button == button_index)

    method is_release->Logical [macro]
      (this.type == PointerEvent.RELEASE)

    method is_release( button_index:Int32 )->Logical
      return (this.type == RELEASE and button == button_index)

    method is_scroll->Logical [macro]
      (this.type == PointerEvent.SCROLL)

    method to->String
      local buffer = StringBuilder()
      buffer.print( "Pointer " ).print( id ).print( " " )
      which (type)
        case MOVEMENT: buffer.print( "movement" )
        case PRESS:    buffer.print( "press button " ).print( button )
        case RELEASE:  buffer.print( "release" )
        case SCROLL:   buffer.print( "scroll " ).print( delta )
      endWhich
      buffer.print( " at " ).print( position )
      if (is_consumed) buffer.print( " (consumed)" )

      return buffer->String
endClass

