module Plasmacore

#{
class Font
  PROPERTIES
    data           : FontData
    options        : PropertyTable

    anchor         = Anchor.TOP_LEFT : Anchor
    scale          = XY(1,1)
    spacing        = 0  # Added to each character's 'advance' (usually the width) to position the next character
    color          = Color(0xFFFFFFFF)

  METHODS
    method init( name:String, options=null )
      data = FontManager.get_font_data( name, null, options )
      set_options( options )

    method init( name:String, height:Int32, options=null )
      data = FontManager.get_font_data( name, height, options )
      set_options( options )

    method draw( text:String, position:XY )
      if (data) data.draw( this, text, position )

    method get( ch:Character )->FontCharacter
      return select{ data:data[ ch ] || null }

    method height->Real64
      if (data) return data.height * scale.y
      else      return 0

    method set_options( @options )->this
      if (not options) return this

      if (options.contains("anchor")) anchor = Anchor( options["anchor"] )
      if (options.contains("snug")) spacing = -1
      if (options.contains("spacing")) spacing = options.get_int32( "spacing" )
      if (options.contains("scale")) scale = XY( options["scale"] )

      return this

    method text_size( text:String )->XY
      return select{ data:data.text_size( text ) * scale || XY(0,0) }

    method text_size( text:StringBuilder )->XY
      return select{ data:data.text_size( text ) * scale || XY(0,0) }

    method text_size( ch:Character )->XY
      return select{ data:data.text_size( ch ) * scale || XY(0,0) }

    method prepare( text=null:String )
      if (data) data.prepare( text )

endClass


class FontData
  PROPERTIES
    loader         : FontLoader
    image          : Image  # Shared between all characters
    height         : Int32
    ascii          = FontCharacter[]( 128, null )
    unicode_lookup : Table<<Character,FontCharacter>>  # Note: does not contain the ASCII characters

  METHODS
    method draw( font:Font, text:String, position:XY  )
      prepare( text )

      if (font.color.argb == 0xFFFFFFFF)
        image.shader = Shader.TEXTURE
      else
        image.shader = Shader.TEXTURE_WITH_COLOR_MULTIPLY
      endIf
      image.color = font.color

      local cursor = position - Box(text_size(text)*font.scale).at( font.anchor ).floor
      forEach (ch in text)
        local info = this[ ch ]
        if (info)
          image.adjust_subset( info.bounds )
          image.draw( cursor+info.offset * font.scale, info.size * font.scale, Anchor.TOP_LEFT )
          cursor += info.advance * font.scale + XY(font.spacing,0) * font.scale
        endIf
      endForEach

    method get( ch:Character )->FontCharacter
      if (ch <= 127)      return ascii[ ch ]
      if (unicode_lookup) return unicode_lookup[ ch ]
      return null

    method load( ch:Character )
      noAction

    method prepare( characters=null:String )
      noAction

    method text_size( text:String )->XY
      local w = 0.0
      forEach (ch in text)
        local info = this[ ch ]
        if (info) w += info.advance.x
      endForEach
      return XY( w, height )

    method text_size( text:StringBuilder )->XY
      local w = 0.0
      forEach (ch in text)
        local info = this[ ch ]
        if (info) w += info.advance.x
      endForEach
      return XY( w, height )

    method text_size( ch:Character )->XY
      local info = this[ ch ]
      if (not info) return XY(0,0)
      return info.advance
endClass


class DynamicallyLoadedFontData : FontData
  PROPERTIES
    bitmap         : Bitmap
    cursor_x=1     : Int32  # For writing new characters into the font bitmap
    cursor_y=1     : Int32
    is_modified    : Logical

  METHODS
    method init( loader, height )
      bitmap = Bitmap( 1024, height+2 )

    method load( ch:Character )
      local info = this[ ch ]
      if (info) return

      is_modified = true
      info = FontCharacter( this, ch )
      info.size = XY(0,height)
      local data = loader.load( info )
      if (not data) return

      local w = data.width

      if (cursor_x + w+1 > bitmap.width)
        cursor_x = 1
        cursor_y += height+2
        bitmap.add_rows( height+2 )
      endIf

      if (data.height > height)
        # This character is taller than the nominal max height of the font.
        # Make room for it and adjust the height.
        bitmap.add_rows( data.height - height )
        height = data.height
      endIf

      data.blit( bitmap, XY(cursor_x,cursor_y) )
      bitmap.extend_edges( Box(cursor_x,cursor_y,w,height) )

      info.top_left = XY( cursor_x, cursor_y )
      if (ch <= 127)
        ascii[ ch ] = info
      else
        if (not unicode_lookup) unicode_lookup = Table<<Character,FontCharacter>>()
        unicode_lookup[ ch ] = info
      endIf

      cursor_x += w + 2

    method prepare( characters=null:String )
      if (characters)
        forEach (ch in characters) load( ch )
      endIf

      if (not is_modified) return
      is_modified = false

      # Adjust all of the offsets to be non-negative, meaning the "pen position" is in
      # the top-left corner.  This means that when a font character is first used
      # that is higher than any other, all text being drawn in that font will appear
      # to shift down a few pixels on screen.  The font being prepare()d with all ASCII
      # letters *should* make this rare.
      local max_negative_offset = XY(0,0)
      forEach (info in ascii)
        if (info) max_negative_offset = max_negative_offset.min( info.offset )
      endForEach
      if (unicode_lookup)
        forEach (key in unicode_lookup.keys)
          local info = unicode_lookup[ key ]
          max_negative_offset = max_negative_offset.min( info.offset )
        endForEach
      endIf

      if (max_negative_offset.x < 0 or max_negative_offset.y < 0)
        local normalizing_offset = -max_negative_offset
        forEach (info in ascii)
          if (info) info.offset += normalizing_offset
        endForEach
        if (unicode_lookup)
          forEach (key in unicode_lookup.keys)
            local info = unicode_lookup[ key ]
            info.offset += normalizing_offset
          endForEach
        endIf
      endIf

      if (image)
        # Changing the bitmap version will automatically update the texture
        # when the image is prepare()d.  Other images based on the texture
        # (such as character images) will automatically update as well.
        ++bitmap.version
        image.prepare
      else
        image = Image( bitmap )
      endIf

endClass


class FontCharacter
  PROPERTIES
    font_data : FontData
    unicode   : Character

    exists    : Logical
    top_left  : XY
    size      : XY

    offset    : XY
    advance   : XY

  METHODS
    method init( font_data, unicode )

    method bounds->Box
      return Box( top_left, size )

    method height->Int32 [macro]
      Int32(size.y)

    method width->Int32 [macro]
      Int32(size.x)
endClass


class FontLoader
  PROPERTIES
    name               : String
    options            : PropertyTable
    error              : Logical
    default_characters : String

  METHODS
    method create_font_data( height:Int32 )->FontData
      throw UnsupportedOperationError( "FontLoader.create_font_data(Int32)" )

    method load( info:FontCharacter )->Bitmap
      return null

    method nominal_height->Int32
      return 16
endClass


class BitmapFontLoader : FontLoader
  PROPERTIES
    bitmap           : Bitmap
    character_width  : Int32
    character_height : Int32

  METHODS
    method init( name, options )
      local filepath = Plasmacore.find_asset( name )
      if (not filepath)
        error = true
        println ''ERROR loading bitmap font "$" - no such file.'' (name)
        return
      endIf

      bitmap = Bitmap( File(filepath) )
      if (bitmap.error)
        error = true
        println ''ERROR loading bitmap font "$" - failed to decode.'' (name)
        return
      endIf

      if (options and options.contains("characters"))
        default_characters = options.get_string( "characters" )
      else
        default_characters = String( (' '..'~')->Character[] )
      endIf

      character_width  = bitmap.width / default_characters.count
      character_height = bitmap.height

    method create_font_data( height:Int32 )->FontData
      return DynamicallyLoadedFontData( this, height )

    method load( info:FontCharacter )->Bitmap
      local i = default_characters.locate( info.unicode )
      if (not i.exists) return null

      local pos  = XY( i.value * character_width, 0 )
      local size = XY( character_width, character_height )

      local bmp = Bitmap( bitmap, Box(pos,size) )

      if (info.height and info.height != bmp.height)
        # Resize the resulting bitmap to match the requested height
        local scale = info.height / Real64(bmp.height)
        bmp.resize( XY(scale*bmp.width,info.height) )
      endIf

      info.exists  = true
      info.size    = bmp.size
      info.advance = bmp.size.xv

      return bmp

    method nominal_height->Int32
      return character_height
endClass


class TrueTypeFontLoader : FontLoader [requisite]
  CLASS
    nativeHeader
      #include "ft2build.h"
      #include FT_FREETYPE_H
    endNativeHeader

    nativeCode
      FT_Library Plasmacore_freetype_library;
    endNativeCode

  PROPERTIES
    native "FT_Face ft_face;"

  METHODS
    method init( name, options )
      if (options and options.contains("characters"))
        default_characters = options.get_string( "characters" )
      else
        default_characters = String( (' '..'~')->Character[] )
      endIf

      local filepath = Plasmacore.find_asset( name )
      if (not filepath)
        error = true
        println ''ERROR loading TrueType font "$" - no such file.'' (name)
        return
      endIf

      if (not native("Plasmacore_freetype_library")->Logical)
        # Initialize FreeType library
        if (native("FT_Init_FreeType(&Plasmacore_freetype_library)")->Int32)
          error = true
          throw Error( "FreeType library failed to initialize." )
        endIf
        on_exit( function native "FT_Done_FreeType( Plasmacore_freetype_library );" )
      endIf

      if (native("FT_New_Face( Plasmacore_freetype_library, (char*)$filepath->utf8, 0, &$this->ft_face )")->Int32)
        error = true
        throw Error( "Error loading $." (name) )
        return
      endIf

    method create_font_data( height:Int32 )->FontData
      return DynamicallyLoadedFontData( this, height )

    method load( info:FontCharacter )->Bitmap
      local w = info.size.x
      local h = info.size.y
      native "FT_Set_Pixel_Sizes( $this->ft_face, $w, $h );"
      if (native("FT_Load_Char( $this->ft_face, $info->unicode, FT_LOAD_RENDER )")->Int32) return null

      info.exists = true
      w = native( "(RogueInt32)$this->ft_face->glyph->bitmap.width" )->Int32
      h = native( "(RogueInt32)$this->ft_face->glyph->bitmap.rows" )->Int32
      info.size = XY( w, h )

      local offset_x = native( "(RogueInt32) $this->ft_face->glyph->bitmap_left" )->Int32
      local offset_y = native( "(RogueInt32)-$this->ft_face->glyph->bitmap_top" )->Int32
      info.offset = XY( offset_x, offset_y )

      local advance_x = native( "(RogueInt32)$this->ft_face->glyph->advance.x" )->Int32
      local advance_y = native( "(RogueInt32)$this->ft_face->glyph->advance.y" )->Int32
      info.advance = XY( Real64(advance_x)/64.0, Real64(advance_y)/64.0 )

      local pitch = native( "(RogueInt32)$this->ft_face->glyph->bitmap.pitch" )->Int32
      native "RogueByte* src = (RogueByte*) $this->ft_face->glyph->bitmap.buffer;"
      local bmp = Bitmap( w, h )
      local src_i = 0
      local dest_i = 0
      local column_skip = pitch - bmp.width
      forEach (j in 1..h)
        forEach (i in 1..w)
          local a = native( "(RogueInt32)(src[$src_i++])" )->Int32
          bmp.pixels[dest_i] = Color(255,255,255,a)
          ++dest_i
        endForEach
        src_i += column_skip
      endForEach

      return bmp

endClass


class FontManager [singleton]
  PROPERTIES
    loader_lookup    = Table<<String,FontLoader>>()
    font_data_lookup = Table<<String,Table<<Int32,FontData>>>>()

  METHODS
    method get_font_data( name:String, height=null:Int32?, options=null:PropertyTable )->FontData
      if (not height.exists)
        local loader = get_loader( name )
        if (not loader) return null
        height = loader.nominal_height
      endIf

      local by_height = font_data_lookup[ name ]
      if (by_height)
        local result = by_height[ height.value ]
        if (result) return result
      else
        by_height = Table<<Int32,FontData>>()
        font_data_lookup[ name ] = by_height
      endIf

      local loader = get_loader( name )
      if (not loader) return null
      local result = loader.create_font_data( height.value )
      by_height[ height.value ] = result

      # Preload the default characters - usually the 95 ASCII characters
      result.prepare( loader.default_characters )

      return result

    method get_loader( name:String, options=null:PropertyTable )->FontLoader
      # low_ch and high_ch are used for bitmap fonts only.
      local loader = loader_lookup[ name ]
      if (loader) return loader

      local lc_name = name.to_lowercase
      if (lc_name.ends_with(".png") or lc_name.ends_with(".jpg"))
        loader = BitmapFontLoader( name, options )
      elseIf (lc_name.ends_with(".ttf") or lc_name.ends_with(".otf"))
        loader = TrueTypeFontLoader( name, options )
      endIf

      if (not loader or loader.error)
        println ''ERROR loading font "$" - unsupported file type.'' (name)
        return null
      endIf

      loader_lookup[ name ] = loader
      return loader

endClass


}#
