module Plasmacore

class Font
  PROPERTIES
    name    : String
    height  : Int32
    data    : FontData
    anchor  = Anchor.TOP_LEFT : Anchor
    scale   = XY(1,1)
    spacing = 0  # Added to each character's width to position the next character
    color   = 0xFFFFFFFF
    options : PropertyTable

  METHODS
    method init( name, height, options=PropertyTable() )
      data = FontManager.font_data[ name ]
      if (not data) load_bitmap_font

      set_options( options )

    method load_bitmap_font
      local characters : String
      if (options.contains("characters")) characters = options.get_string( "characters" )
      else characters = String( (' '..'~')->Character[] )

      local filepath = Plasmacore.find_asset( name )
      if (not filepath)
        println "ERROR loading BitmapFont - no such file $." (name)
        return
      endIf

      local src = Bitmap( File(filepath) )
      if (src.error) return

      data = FontData( height )
      FontManager.font_data[ name ] = data

      local width : Int32
      if (options.contains("width")) width = options.get_int32("width")
      else                           width = src.width / characters.count

      local src_w = src.width / width
      local src_h = src.height / height

      local ch_index = 0
      forEach (j in 0..<src_h)
        forEach (i in 0..<src_w)
          local x = i * width
          local y = j * height
          local ch_data = Bitmap( src, Box(x,y,width,height) )
          data.define( characters[ch_index], ch_data )
          ++ch_index
        endForEach
      endForEach

      prepare

    method draw( text:String, position:XY )
      if (color == 0xFFFFFFFF)
        FontCharacter.shared_image.shader = Shader.TEXTURE
      else
        FontCharacter.shared_image.shader = Shader.TEXTURE_WITH_COLOR_MULTIPLY
      endIf
      FontCharacter.shared_image.color = color

      local cursor = position - Box(text_size(text)).at( anchor ).floor
      forEach (ch in text)
        local info = this[ ch ]
        if (info)
          local img = info.image
          img.draw( cursor, info.size, Anchor.TOP_LEFT )
          cursor.x += info.size.x + spacing
        endIf
      endForEach

    method get( ch:Character )->FontCharacter
      return data[ ch ]

    method set_options( @options )->this
      if (options.contains("anchor")) anchor = Anchor( options["anchor"] )
      if (options.contains("snug")) spacing = -1
      if (options.contains("spacing")) spacing = options.get_int32( "spacing" )
      if (options.contains("scale")) scale = XY( options["scale"] )

      return this

    method text_size( text:String )->XY
      local w = 0.0
      forEach (ch in text)
        local info = this[ ch ]
        if (info) w += info.size.x
      endForEach
      return XY( w, height )

    method text_size( text:StringBuilder )->XY
      local result = XY(0,0)
      forEach (ch in text)
        local info = this[ ch ]
        if (info) result += info.size
      endForEach
      return result

    method text_size( ch:Character )->XY
      local info = this[ ch ]
      if (not info) return XY(0,0)
      return info.size

    method prepare
      if (data) data.prepare

endClass


class FontData
  PROPERTIES
    bitmap      : Bitmap
    image       : Image
    height      : Int32
    cursor_x=1  : Int32  # For writing new characters into the font bitmap
    cursor_y=1  : Int32
    ascii       = FontCharacter[]( 128, null )
    lookup      : Table<<Character,FontCharacter>>  # Note: does not contain the ASCII characters
    is_modified : Logical

  METHODS
    method init( height )
      bitmap = Bitmap( 1024, height+2 )
      image = Image( bitmap )
      FontCharacter.shared_image = Image( image, Box(0,0,1,1) )

    method define( ch:Character, data:Bitmap )
      is_modified = true
      local w = data.width

      if (cursor_x + w+1 > bitmap.width)
        cursor_x = 1
        cursor_y += height+2
        bitmap.add_rows( height+2 )
      endIf

      if (data.height > height)
        # This character is taller than the nominal max height of the font.
        # Make room for it and adjust the height.
        bitmap.add_rows( data.height - height )
        height = data.height
      endIf

      data.blit( bitmap, XY(cursor_x,cursor_y) )
      bitmap.extend_edges( Box(cursor_x,cursor_y,w,height) )

      local info = FontCharacter( this, ch, XY(cursor_x,cursor_y), XY(w,height) )
      if (ch <= 127)
        ascii[ ch ] = info
      else
        if (not lookup) lookup = Table<<Character,FontCharacter>>()
        lookup[ ch ] = info
      endIf

      cursor_x += w + 2

    method get( ch:Character )->FontCharacter
      if (ch <= 127) return ascii[ ch ]
      if (lookup)    return lookup[ ch ]
      return null

    method prepare
      if (not is_modified) return
      is_modified = false

      if (image)
        # Changing the bitmap version will automatically update the texture
        # when the image is prepare()d.  Other images based on the texture
        # (such as character images) will automatically update as well.
        ++bitmap.version
        image.prepare
      else
        image = Image( bitmap )
      endIf

endClass


class FontCharacter
  GLOBAL PROPERTIES
    shared_image : Image

  PROPERTIES
    font_data : FontData
    unicode   : Character
    top_left  : XY
    size      : XY
    offset_x  : Int32
    offset_y  : Int32

  METHODS
    method init( font_data, unicode, top_left, size )

    method image->Image
      shared_image.adjust_subset( Box(top_left,size) )
      return shared_image

endClass


class FontManager [singleton]
  PROPERTIES
    font_data = Table<<String,FontData>>()
endClass
