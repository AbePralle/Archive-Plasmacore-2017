#==============================================================================
# Messaging.rogue
#==============================================================================

$module Plasmacore

$requisite Byte[].clear()
$requisite Byte[].reserve(Int32)

class MessageManager [requisite singleton]
  PROPERTIES
    incoming_buffer = Byte[]  # native layer accesses this directly
    reader          = BufferedDataReader( incoming_buffer )

    alpha_writer    = BufferedDataWriter()
    beta_writer     = BufferedDataWriter()
    writer          = alpha_writer : BufferedDataWriter

    next_id = 1

    incoming_id_to_name = Table<<Int32,String>>()
    outgoing_name_to_id = Table<<String,Int32>>()

    incoming_message = IncomingMessage()
      # Recycled for received messages

    outgoing_message = OutgoingMessage()
      # Recycled for outgoing messages

    listeners                        = Table<<String,Function(Message)[]>>()
    reply_callbacks_by_id = Table<<Int32,Function(Message)>>()

  METHODS
    method init_object
      add_listener( "<reply>",
        function(m:Message)
          local callback = MessageManager.reply_callbacks_by_id.remove( m.id )
          if (callback) callback( m )
        endFunction
      )

    method add_listener( type:String, listener:Function(Message) )
      local list = listeners[ type ]
      if (not list)
        list = Function(Message)[]
        listeners[ type ] = list
      endIf
      list.add( listener )

    method remove_listener( type:String, listener:Function(Message) )
      local list = listeners[ type ]
      if (list) list.remove( listener )

    method message( type:String, id=null:Int32? )->Message
      if (not id.exists)
        id = next_id
        ++next_id
      endIf
      outgoing_message.init( type, id.value )
      return outgoing_message

    method send( m:OutgoingMessage )
      writer.write_int32( m.writer.buffer.count )
      writer.write( m.writer.buffer )

    method send_rsvp( m:OutgoingMessage, callback:Function(Message) )
      send( m )
      reply_callbacks_by_id[ m.id ] = callback

    method update->Byte[] [requisite]
      # 'reader' has already been set up to decode 'incoming_buffer', which 
      # in turn has already been filled with incoming message bytes by the
      # native layer.
      reader.reset( 0 )

      while (reader.has_another)
        incoming_message.init( reader )
        local list = listeners[ incoming_message.type ]
        if (list)
          forEach (listener in list step -1) listener( incoming_message )
        endIf
      endWhile

      # Alternate output writers to allow Rogue code to indirectly generate more output
      # messages while the native layer is processing our previous messages.
      if (writer is alpha_writer)
        writer = beta_writer.clear
        return alpha_writer.buffer
      else
        writer = alpha_writer.clear
        return beta_writer.buffer
      endIf
endClass

class Message
  ENUMERATE
    DATA_TYPE_ID_DEFINITION = 0
    DATA_TYPE_ID            = 1
    DATA_TYPE_STRING        = 2
    DATA_TYPE_REAL64        = 3
    DATA_TYPE_INT64         = 4
    DATA_TYPE_INT32         = 5
    DATA_TYPE_LOGICAL       = 6
    DATA_TYPE_REAL64_LIST   = 7
    DATA_TYPE_INT32_LIST    = 8
    DATA_TYPE_BYTE_LIST     = 9

  PROPERTIES
    type          : String
    id : Int32

  METHODS
    method contains( name:String )->Logical
      throw UnsupportedOperationError( "$::contains()" (type_name) )

    method get_string( name:String, default="":String )->String
      throw UnsupportedOperationError( "$::get_string()" (type_name) )

    method get_string( name:String, buffer:StringBuilder )->StringBuilder
      throw UnsupportedOperationError( "$::get_string()" (type_name) )

    method get_real64( name:String, default=0:Real64 )->Real64
      throw UnsupportedOperationError( "$::get_real64()" (type_name) )

    method get_int64( name:String, default=0:Int64 )->Int64
      throw UnsupportedOperationError( "$::get_int64()" (type_name) )

    method get_int32( name:String, default=0:Int32 )->Int32
      throw UnsupportedOperationError( "$::get_int32()" (type_name) )

    method get_logical( name:String, default=false:Logical )->Logical
      throw UnsupportedOperationError( "$::get_logical()" (type_name) )

    method get_real64_list( name:String, list=Real64[]:Real64[] )->Real64[]
      throw UnsupportedOperationError( "$::get_real64_list()" (type_name) )

    method get_int32_list( name:String, list=Int32[]:Int32[] )->Int32[]
      throw UnsupportedOperationError( "$::get_int32_list()" (type_name) )

    method get_byte_list( name:String, bytes=Byte[]:Byte[] )->Byte[]
      throw UnsupportedOperationError( "$::get_byte_list()" (type_name) )

    method reply->Message
      throw UnsupportedOperationError( "$::reply()" (type_name) )

    method set_string( name:String, value:String )->this
      throw UnsupportedOperationError( "$::set_string()" (type_name) )

    method set_real64( name:String, value:Real64 )->this
      throw UnsupportedOperationError( "$::set_real64()" (type_name) )

    method set_int64( name:String, value:Int64 )->this
      throw UnsupportedOperationError( "$::set_int64()" (type_name) )

    method set_int32( name:String, value:Int32 )->this
      throw UnsupportedOperationError( "$::set_int32()" (type_name) )

    method set_logical( name:String, value:Logical )->this
      throw UnsupportedOperationError( "$::set_logical()" (type_name) )

    method set_real64_list( name:String, list:Real64[] )->this
      throw UnsupportedOperationError( "$::set_real64_list()" (type_name) )

    method set_int32_list( name:String, list:Int32[] )->this
      throw UnsupportedOperationError( "$::set_int32_list()" (type_name) )

    method set_byte_list( name:String, bytes:Byte[] )->this
      throw UnsupportedOperationError( "$::set_byte_list()" (type_name) )

    method send
      throw UnsupportedOperationError( "$::send()" (type_name) )

    method send_rsvp( callback:Function(Message) )
      throw UnsupportedOperationError( "$::send_rsvp()" (type_name) )
endClass

class IncomingMessage : Message
  PROPERTIES
    reader    = BufferedDataReader()
    id_buffer = StringBuilder()
    keys      = String[]
    offsets   = Int32[]

  METHODS
    method init
      
    method init( source:DataReader )
      local size = source.read_int32
      source.read( reader.buffer.clear, size )
      reader.reset( 0 )
      type = read_id
      id = reader.read_int32x
      while (index_another) noAction

    method contains( name:String )->Logical
      return keys.locate(name).exists

    method get_string( name:String, default="":String )->String
      local i = keys.locate_last( name )
      if (not i.exists) return default

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_STRING, DATA_TYPE_BYTE_LIST
          return reader.read_string
      endWhich

      return default

    method get_string( name:String, buffer:StringBuilder )->StringBuilder
      return buffer

    method get_real64( name:String, default=0:Real64 )->Real64
      local i = keys.locate_last( name )
      if (not i.exists) return default

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_REAL64
          return reader.read_real64

        case DATA_TYPE_INT64
          return reader.read_int64x

        case DATA_TYPE_INT32, DATA_TYPE_LOGICAL
          return reader.read_int32x
      endWhich

      return default

    method get_int64( name:String, default=0:Int64 )->Int64
      local i = keys.locate_last( name )
      if (not i.exists) return default

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_REAL64
          return reader.read_real64->Int64

        case DATA_TYPE_INT64
          return reader.read_int64x

        case DATA_TYPE_INT32, DATA_TYPE_LOGICAL
          return reader.read_int32x
      endWhich

      return default

    method get_int32( name:String, default=0:Int32 )->Int32
      local i = keys.locate_last( name )
      if (not i.exists) return default

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_REAL64
          return reader.read_real64->Int32

        case DATA_TYPE_INT64
          return reader.read_int64x->Int32

        case DATA_TYPE_INT32, DATA_TYPE_LOGICAL
          return reader.read_int32x
      endWhich

      return default

    method get_logical( name:String, default=false:Logical )->Logical
      local i = keys.locate_last( name )
      if (not i.exists) return default

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_REAL64
          return reader.read_real64 != 0

        case DATA_TYPE_INT64
          return reader.read_int64x != 0

        case DATA_TYPE_INT32, DATA_TYPE_LOGICAL
          return reader.read_int32x != 0
      endWhich

      return default

    method get_real64_list( name:String, list=Real64[]:Real64[] )->Real64[]
      local i = keys.locate_last( name )
      if (not i.exists) return list

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_REAL64_LIST
          local count = reader.read_int32x
          list.reserve( count )
          forEach (1..count) list.add( reader.read_real64 )
      endWhich

      return list

    method get_int32_list( name:String, list=Int32[]:Int32[] )->Int32[]
      local i = keys.locate_last( name )
      if (not i.exists) return list

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_INT32_LIST
          local count = reader.read_int32x
          list.reserve( count )
          forEach (1..count) list.add( reader.read_int32x )
      endWhich

      return list

    method get_byte_list( name:String, bytes=Byte[]:Byte[] )->Byte[]
      local i = keys.locate_last( name )
      if (not i.exists) return bytes

      reader.reset( offsets[i.value] )
      which (reader.read_int32x)
        case DATA_TYPE_STRING, DATA_TYPE_BYTE_LIST
          local count = reader.read_int32x
          bytes.reserve( count )
          forEach (1..count) bytes.add( reader.read_int32x->Byte )
      endWhich

      return bytes

    # INTERNAL USE
    method index_another->Logical
      if (not reader.has_another) return false
      local key    = read_id
      local offset = reader.position
      keys.add( key )
      offsets.add( offset )

      # Skip value
      local data_type = reader.read_int32x
      which (data_type)
        case DATA_TYPE_ID_DEFINITION, DATA_TYPE_ID
          read_id

        case DATA_TYPE_STRING, DATA_TYPE_BYTE_LIST, DATA_TYPE_INT32_LIST
          read_id
          local count = reader.read_int32x
          forEach (1..count) reader.read_int32x

        case DATA_TYPE_REAL64
          reader.read_real64

        case DATA_TYPE_INT64
          reader.read_int64x

        case DATA_TYPE_INT32, DATA_TYPE_LOGICAL
          reader.read_int32x

        case DATA_TYPE_REAL64_LIST
          read_id
          local count = reader.read_int32x
          forEach (1..count) reader.read_real64

        others
          println "ERROR: unsupported message data type $." (data_type)
      endWhich
      return true

    method read_id->String
      local id_type = reader.read_int32x
      which (id_type)
        case DATA_TYPE_ID_DEFINITION
          local id = reader.read_int32x
          local name = MessageManager.incoming_id_to_name[ id ]
          if (name)
            reader.read_string( id_buffer.clear )  # skip the definition
          else
            name = reader.read_string( id_buffer.clear )->String
            MessageManager.incoming_id_to_name[ id ] = name
          endIf
          return name

        case DATA_TYPE_ID
          local id = reader.read_int32x
          local name = MessageManager.incoming_id_to_name[ id ]
          if (name) return name
          println "ERROR: undefined message ID."

        others
          println "ERROR: message ID expected."
      endWhich

      return "Undefined"

    method reply->Message
      return MessageManager.message( "<reply>", id )

endClass

class OutgoingMessage : Message
  PROPERTIES
    sent   = true
    writer = BufferedDataWriter()

  METHODS
    method init

    method init( new_type:String, id )
      if (not sent) println "ERROR: unsent outgoing message of type '$'." (type)
      type = new_type
      sent = false
      writer.clear

      write_id( type )
      writer.write_int32x( id )

    method write_id( value:String )->this
      local entry = MessageManager.outgoing_name_to_id.find( value )
      if (entry)
        writer.write_int32x( Message.DATA_TYPE_ID )
        writer.write_int32x( entry.value )
      else
        writer.write_int32x( Message.DATA_TYPE_ID_DEFINITION )
        local id = MessageManager.outgoing_name_to_id.count
        MessageManager.outgoing_name_to_id[ value ] = id
        writer.write_int32x( id )
        writer.write_string( value )
      endIf
      return this

    method set_string( name:String, value:String )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_STRING ).write_string( value )
      return this

    method set_real64( name:String, value:Real64 )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_REAL64 ).write_real64( value )
      return this

    method set_int64( name:String, value:Int64 )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_INT64 ).write_int64x( value )
      return this

    method set_int32( name:String, value:Int32 )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_INT32 ).write_int32x( value )
      return this

    method set_logical( name:String, value:Logical )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_LOGICAL ).write_logical( value )
      return this

    method set_real64_list( name:String, list:Real64[] )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_REAL64_LIST ).write_int32x( list.count )
      forEach (value in list) writer.write_real64( value )
      return this

    method set_int32_list( name:String, list:Int32[] )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_INT32_LIST ).write_int32x( list.count )
      forEach (value in list) writer.write_int32x( value )
      return this

    method set_byte_list( name:String, bytes:Byte[] )->this
      write_id( name )
      writer.write_int32x( Message.DATA_TYPE_BYTE_LIST ).write_int32x( bytes.count )
      forEach (b in bytes) writer.write_int32x( b )
      return this

    method send
      MessageManager.send( this )
      sent = true

    method send_rsvp( callback:Function(Message) )
      MessageManager.send_rsvp( this, callback )
      sent = true
endClass

