module Plasmacore

class Color( argb:Int32 ) [compound]
  DEFINITIONS
    BLACK       = Color( 0xff000000 )
    BLUE        = Color( 0xff0000ff )
    BROWN       = Color( 0xff802a2a )
    CYAN        = Color( 0xff00ffff )
    GRAY        = Color( 0xff808080 )
    GREEN       = Color( 0xff008000 )
    LIME        = Color( 0xff00ff00 )
    MAGENTA     = Color( 0xffff00ff )
    ORANGE      = Color( 0xffffa500 )
    PURPLE      = Color( 0xff800080 )
    RED         = Color( 0xffff0000 )
    YELLOW      = Color( 0xffffff00 )
    WHITE       = Color( 0xffffffff )

  GLOBAL METHODS
    method create( r:Int32, g:Int32, b:Int32, a=255:Int32 )->Color
      return (a.clamped(0,255):<<:24 | r.clamped(0,255):<<:16 | g.clamped(0,255):<<:8 | b.clamped(0,255))

  METHODS
    method alpha->Int32
      return (argb :>>: 24) & 255

    method blue->Int32
      return argb & 255

    method green->Int32
      return (argb :>>: 8) & 255

    method is_opaque->Logical
      return ((argb & 0xFF000000) == 0xFF000000)

    method red->Int32
      return (argb :>>: 16) & 255

    method with_alpha( a:Int32 )->Color
      return Color( (a :<<: 24) | (this.argb & 0xFFffFF) )

    method to->String
      return argb.to_hex_string
endClass


class RealColor( r=0:Real64, g=0:Real64, b=0:Real64, a=1:Real64 )
  METHODS
    method to->Color
      return (((a.clamped(0,1)*255)->Int32:<<:24) | ((r.clamped(0,1)*255)->Int32:<<:16) |
             ((g.clamped(0,1)*255)->Int32:<<:8) | (b.clamped(0,1)*255)->Int32 )
endClass


class Colors( a:Color, b:Color, c:Color, d:Color, count=4:Int32 ) [compound]
  GLOBAL METHODS
    method create( color:Color )->Colors
      return Colors( color, color, color, color, 4 )

    method create( a:Color, b:Color )->Colors
      return Colors( a, b, Color(0), Color(0), 2 )

    method create( a:Color, b:Color, c:Color )->Colors
      return Colors( a, b, c, Color(0), 3 )

    method create( a:Color, b:Color, c:Color, d:Color )->Colors
      return Colors( a, b, c, d, 4 )

    method create( color:Int32 )->Colors
      return Colors( Color(color), Color(color), Color(color), Color(color), 4 )

    method create( a:Int32, b:Int32 )->Colors
      return Colors( Color(a), Color(b), Color(0), Color(0), 2 )

    method create( a:Int32, b:Int32, c:Int32 )->Colors
      return Colors( Color(a), Color(b), Color(c), Color(0), 3 )

    method create( a:Int32, b:Int32, c:Int32, d:Int32, count=4:Int32 )->Colors
      return Colors( Color(a), Color(b), Color(c), Color(d), count )

  METHODS
    method is_opaque->Logical
      which (count)
        case 4: return ((a.argb & b.argb & c.argb & d.argb & 0xFF000000) == 0xFF000000)
        case 3: return ((a.argb & b.argb & c.argb & 0xFF000000) == 0xFF000000)
        case 2: return ((a.argb & b.argb & 0xFF000000) == 0xFF000000)
        case 1: return ((a.argb & 0xFF000000) == 0xFF000000)
        case 0: return true
        others: return false
      endWhich

    method is_opaque_white->Logical
      which (count)
        case 4: return ((a.argb & b.argb & c.argb & d.argb) == 0xFFFFFFFF)
        case 3: return ((a.argb & b.argb & c.argb) == 0xFFFFFFFF)
        case 2: return ((a.argb & b.argb) == 0xFFFFFFFF)
        case 1: return ((a.argb) == 0xFFFFFFFF)
        case 0: return true
        others: return false
      endWhich

    method operator&( n:Int32 )->Colors
      return Colors( a.argb&n, b.argb&n, c.argb&n, d.argb&n, count )

    method operator|( n:Int32 )->Colors
      return Colors( a.argb|n, b.argb|n, c.argb|n, d.argb|n, count )

    method operator!->Colors
      return Colors( !a.argb, !b.argb, !c.argb, !d.argb, count )
endClass

