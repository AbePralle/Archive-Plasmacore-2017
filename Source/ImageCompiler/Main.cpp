#include "Build/ImageCompiler.h"
#include "png.h"

RogueByte png_data[] =
{
0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A,0x00,0x00,0x00,0x0D,0x49,0x48,0x44,0x52,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x08,0x02,0x00,0x00,0x00,0x12,0x16,0xF1,0x4D,0x00,0x00,0x00,0x01,0x73,0x52,0x47,0x42,0x00,0xAE,0xCE,0x1C,0xE9,0x00,0x00,0x00,0x09,0x70,0x48,0x59,0x73,0x00,0x00,0x0B,0x13,0x00,0x00,0x0B,0x13,0x01,0x00,0x9A,0x9C,0x18,0x00,0x00,0x02,0x72,0x69,0x54,0x58,0x74,0x58,0x4D,0x4C,0x3A,0x63,0x6F,0x6D,0x2E,0x61,0x64,0x6F,0x62,0x65,0x2E,0x78,0x6D,0x70,0x00,0x00,0x00,0x00,0x00,0x3C,0x78,0x3A,0x78,0x6D,0x70,0x6D,0x65,0x74,0x61,0x20,0x78,0x6D,0x6C,0x6E,0x73,0x3A,0x78,0x3D,0x22,0x61,0x64,0x6F,0x62,0x65,0x3A,0x6E,0x73,0x3A,0x6D,0x65,0x74,0x61,0x2F,0x22,0x20,0x78,0x3A,0x78,0x6D,0x70,0x74,0x6B,0x3D,0x22,0x58,0x4D,0x50,0x20,0x43,0x6F,0x72,0x65,0x20,0x35,0x2E,0x34,0x2E,0x30,0x22,0x3E,0x0A,0x20,0x20,0x20,0x3C,0x72,0x64,0x66,0x3A,0x52,0x44,0x46,0x20,0x78,0x6D,0x6C,0x6E,0x73,0x3A,0x72,0x64,0x66,0x3D,0x22,0x68,0x74,0x74,0x70,0x3A,0x2F,0x2F,0x77,0x77,0x77,0x2E,0x77,0x33,0x2E,0x6F,0x72,0x67,0x2F,0x31,0x39,0x39,0x39,0x2F,0x30,0x32,0x2F,0x32,0x32,0x2D,0x72,0x64,0x66,0x2D,0x73,0x79,0x6E,0x74,0x61,0x78,0x2D,0x6E,0x73,0x23,0x22,0x3E,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x72,0x64,0x66,0x3A,0x44,0x65,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,0x6E,0x20,0x72,0x64,0x66,0x3A,0x61,0x62,0x6F,0x75,0x74,0x3D,0x22,0x22,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x78,0x6D,0x6C,0x6E,0x73,0x3A,0x74,0x69,0x66,0x66,0x3D,0x22,0x68,0x74,0x74,0x70,0x3A,0x2F,0x2F,0x6E,0x73,0x2E,0x61,0x64,0x6F,0x62,0x65,0x2E,0x63,0x6F,0x6D,0x2F,0x74,0x69,0x66,0x66,0x2F,0x31,0x2E,0x30,0x2F,0x22,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x78,0x6D,0x6C,0x6E,0x73,0x3A,0x78,0x6D,0x70,0x3D,0x22,0x68,0x74,0x74,0x70,0x3A,0x2F,0x2F,0x6E,0x73,0x2E,0x61,0x64,0x6F,0x62,0x65,0x2E,0x63,0x6F,0x6D,0x2F,0x78,0x61,0x70,0x2F,0x31,0x2E,0x30,0x2F,0x22,0x3E,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x74,0x69,0x66,0x66,0x3A,0x59,0x52,0x65,0x73,0x6F,0x6C,0x75,0x74,0x69,0x6F,0x6E,0x3E,0x37,0x32,0x3C,0x2F,0x74,0x69,0x66,0x66,0x3A,0x59,0x52,0x65,0x73,0x6F,0x6C,0x75,0x74,0x69,0x6F,0x6E,0x3E,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x74,0x69,0x66,0x66,0x3A,0x43,0x6F,0x6D,0x70,0x72,0x65,0x73,0x73,0x69,0x6F,0x6E,0x3E,0x35,0x3C,0x2F,0x74,0x69,0x66,0x66,0x3A,0x43,0x6F,0x6D,0x70,0x72,0x65,0x73,0x73,0x69,0x6F,0x6E,0x3E,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x74,0x69,0x66,0x66,0x3A,0x58,0x52,0x65,0x73,0x6F,0x6C,0x75,0x74,0x69,0x6F,0x6E,0x3E,0x37,0x32,0x3C,0x2F,0x74,0x69,0x66,0x66,0x3A,0x58,0x52,0x65,0x73,0x6F,0x6C,0x75,0x74,0x69,0x6F,0x6E,0x3E,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x78,0x6D,0x70,0x3A,0x43,0x72,0x65,0x61,0x74,0x6F,0x72,0x54,0x6F,0x6F,0x6C,0x3E,0x46,0x6C,0x79,0x69,0x6E,0x67,0x20,0x4D,0x65,0x61,0x74,0x20,0x41,0x63,0x6F,0x72,0x6E,0x20,0x35,0x2E,0x31,0x2E,0x31,0x3C,0x2F,0x78,0x6D,0x70,0x3A,0x43,0x72,0x65,0x61,0x74,0x6F,0x72,0x54,0x6F,0x6F,0x6C,0x3E,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x78,0x6D,0x70,0x3A,0x4D,0x6F,0x64,0x69,0x66,0x79,0x44,0x61,0x74,0x65,0x3E,0x32,0x30,0x31,0x35,0x2D,0x31,0x31,0x2D,0x31,0x35,0x54,0x32,0x33,0x3A,0x30,0x39,0x3A,0x30,0x31,0x3C,0x2F,0x78,0x6D,0x70,0x3A,0x4D,0x6F,0x64,0x69,0x66,0x79,0x44,0x61,0x74,0x65,0x3E,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x2F,0x72,0x64,0x66,0x3A,0x44,0x65,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6F,0x6E,0x3E,0x0A,0x20,0x20,0x20,0x3C,0x2F,0x72,0x64,0x66,0x3A,0x52,0x44,0x46,0x3E,0x0A,0x3C,0x2F,0x78,0x3A,0x78,0x6D,0x70,0x6D,0x65,0x74,0x61,0x3E,0x0A,0x84,0x34,0xAC,0xC6,0x00,0x00,0x00,0x11,0x49,0x44,0x41,0x54,0x08,0x1D,0x63,0xFC,0xCF,0x00,0x07,0x40,0x26,0x88,0xF7,0x1F,0x00,0x21,0x07,0x03,0xFE,0xAB,0xF0,0xFF,0x69,0x00,0x00,0x00,0x00,0x49,0x45,0x4E,0x44,0xAE,0x42,0x60,0x82
};

struct RoguePNGDecoder
{
  RogueInteger width;
  RogueInteger height;
  RogueInteger bpp;

  jmp_buf      error_jmp_buffer;
  RogueByte*   png_data_cursor;
  RogueInteger png_data_remaining;
};


static void Plasmacore_png_error_handler( png_structp png_ptr, png_const_charp msg )
{
  fprintf(stderr, "libpng error: %s\n", msg);
  fflush(stderr);

  longjmp( ((RoguePNGDecoder*)png_get_io_ptr(png_ptr))->error_jmp_buffer, 1 );
}

static void Plasmacore_png_read_callback( png_structp png_ptr, png_bytep data, png_size_t count )
{
  RoguePNGDecoder* decoder = (RoguePNGDecoder*) png_get_io_ptr( png_ptr );
  if (count > decoder->png_data_remaining) count = (png_size_t) decoder->png_data_remaining;

  if (count)
  {
    memcpy( data, decoder->png_data_cursor, count );
    decoder->png_data_cursor    += count;
    decoder->png_data_remaining -= count;
  }
}

static bool Plasmacore_decode_png( RoguePNGDecoder* decoder, RogueByte* data, int data_size )
{
  png_structp  png_ptr;
  png_infop    info_ptr;

  decoder->png_data_cursor = data;
  decoder->png_data_remaining = (RogueInteger) data_size;

  png_ptr = png_create_read_struct( PNG_LIBPNG_VER_STRING, decoder,
      Plasmacore_png_error_handler, NULL );
  if ( !png_ptr ) return false; // Out of memory

  png_set_add_alpha( png_ptr, 255, PNG_FILLER_AFTER );

  info_ptr = png_create_info_struct(png_ptr);
  if (!info_ptr)
  {
    png_destroy_read_struct( &png_ptr, NULL, NULL );
    return false;  // Out of memory
  }

  if (setjmp(decoder->error_jmp_buffer))
  {
    png_destroy_read_struct( &png_ptr, &info_ptr, NULL );
    return false;
  }

  png_set_read_fn( png_ptr, decoder, Plasmacore_png_read_callback );

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
  // Prepare the reader to ignore all recognized chunks whose data won't be
  // used, i.e., all chunks recognized by libpng except for IHDR, PLTE, IDAT,
  // IEND, tRNS, bKGD, gAMA, and sRGB (small performance improvement).
  {
    static png_byte chunks_to_ignore[] = 
    {
       99,  72,  82,  77, '\0',  // cHRM
      104,  73,  83,  84, '\0',  // hIST
      105,  67,  67,  80, '\0',  // iCCP
      105,  84,  88, 116, '\0',  // iTXt
      111,  70,  70, 115, '\0',  // oFFs
      112,  67,  65,  76, '\0',  // pCAL
      112,  72,  89, 115, '\0',  // pHYs
      115,  66,  73,  84, '\0',  // sBIT
      115,  67,  65,  76, '\0',  // sCAL
      115,  80,  76,  84, '\0',  // sPLT
      115,  84,  69,  82, '\0',  // sTER
      116,  69,  88, 116, '\0',  // tEXt
      116,  73,  77,  69, '\0',  // tIME
      122,  84,  88, 116, '\0'   // zTXt
    };

    png_set_keep_unknown_chunks( png_ptr, PNG_HANDLE_CHUNK_NEVER,
        chunks_to_ignore, sizeof(chunks_to_ignore)/5 );
  }
#endif // PNG_HANDLE_AS_UNKNOWN_SUPPORTED

  png_read_png(
      png_ptr,
      info_ptr,
      PNG_TRANSFORM_STRIP_16 | PNG_TRANSFORM_PACKING | PNG_TRANSFORM_EXPAND | PNG_TRANSFORM_GRAY_TO_RGB,
      NULL
  );

  png_uint_32 width  = png_get_image_width( png_ptr, info_ptr );
  png_uint_32 height = png_get_image_height( png_ptr, info_ptr );

  //Texture_init( NULL, width, height, plasmacore_png_texture_format );

  png_bytepp row_pointers = png_get_rows( png_ptr, info_ptr );

  int row_size = (int) png_get_rowbytes( png_ptr, info_ptr );

  /*
  for (int j=0; j<height; ++j)
  {
    // The appropriate GL texture was prepped just before this PNG decoding
    if (plasmacore_png_texture_format == 1)
    {
      // premultiply the alpha
      int count = width + 1;
      unsigned char* data = row_pointers[j];
      while (--count)
      {
        int a = data[3];
        data[0] = (data[0] * a) / 255;
        data[1] = (data[1] * a) / 255;
        data[2] = (data[2] * a) / 255;
        data += 4;
      }
      glTexSubImage2D( GL_TEXTURE_2D, 0, 0, j, width, 1, GL_RGBA, GL_UNSIGNED_BYTE, row_pointers[j] );
    }
    else
    {
      // premultiply the alpha and convert it to 16-bit
      int count = width + 1;
      unsigned char* src = row_pointers[j];
      unsigned short* dest = ((unsigned short*) row_pointers[j]) - 1;
      while (--count)
      {
        int a = src[3];
        int r = ((src[0] * a) / 255) >> 4;
        int g = ((src[1] * a) / 255) >> 4;
        int b = ((src[2] * a) / 255) >> 4;
        a >>= 4;
        *(++dest) = (unsigned short) ((r<<12) | (g<<8) | (b<<4) | a);
        src  += 4;
      }
      glTexSubImage2D( GL_TEXTURE_2D, 0, 0, j, width, 1, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4, row_pointers[j] );
    }
  }
  */

  png_destroy_read_struct( &png_ptr, &info_ptr, NULL );

  decoder->width = (RogueInteger)  width;
  decoder->height = (RogueInteger) height;

  return true;
}

int main( int argc, const char* argv[] )
{
  Rogue_configure();
  Rogue_launch( argc, argv );

  RoguePNGDecoder decoder;
  Plasmacore_decode_png( &decoder, png_data, sizeof(png_data) );

  Rogue_quit();
  return 0;
}
