$include "../Rogue/Plasmacore"
using Plasmacore

try
  local config_file = File( "Assets/Images/ImageConfig.txt" )
  if (not config_file.exists)
    File.create_folder( config_file.path )
    local writer = PrintWriter(config_file.writer)
    writer.println @|# Default config file - customize as desired.
                    |[Global]
                    |@ **/*Font* varfont
                    |@ **/*font* varfont
                    |
                    |[Default]
                    |set sheet_size:2048
                    |group *
    writer.close
  endIf



  local args = System.command_line_arguments
  if (args.count)
    ImageCompiler( config_file, (forEach in args) )
  else
    ImageCompiler( config_file, "Default" )
  endIf

catch (err:BuildError)
  println err
  System.exit 1
endTry

class BuildError( cmd:Command, message ) : Error
  METHODS
    method init( message )

    method to->String
      local builder = StringBuilder()

      local bar = "=" * Console.width.or_smaller( 79 )
      builder.println bar
      if (cmd)
        builder.println( (''IMAGE COMPILE ERROR in "$" line $'' (cmd.filepath,cmd.line)).word_wrapped(Console.width) )
      else
        builder.println "IMAGE COMPILE ERROR"
      endIf
      builder.println
      builder.println message.word_wrapped( Console.width )
      builder.println bar
      return builder->String
endClass

class ImageCompiler
  PROPERTIES
    file       : File
    platform   : String
    commands   = Table<<String,Command[]>>()
    files      = Table<<String,String>>()
    attributes = @[]

  METHODS
    method init( file, platform )
      organize_commands
      execute_global_commands

    method organize_commands
      local category = "Global"
      forEach (line at index in LineReader(file))
        line = strip_comments( line.trimmed )
        if (line.count == 0) nextIteration
        if (line.begins_with('['))
          local after = line.after_first(']')
          if (after.count) throw BuildError( Command(this,file.filepath,index+1,line), "Syntax error after ']'." )
          category = line.after_first( '[' ).before_first( ']' ).trimmed
        else
          ensure commands[ category ]
          commands[ category ].add( Command(this,file.filepath,index+1,line) )
        endIf
      endForEach

    method execute_global_commands
      if (not commands.contains("Global")) return
      (forEach in commands//Global).execute

    method strip_comments( text:String )->String
      if (not text.contains('#')) return text

      local in_string   = 0
      local ignore_next = false
      forEach (ch at index in text)
        if (ignore_next)
          ignore_next = false
        else
          if (in_string)
            which (ch)
              case '\\':      ignore_next = true
              case in_string: in_string = 0
            endWhich
          else
            which (ch)
              case '"', '\'': in_string = ch
              case '#': return text.leftmost( index )
            endWhich
          endIf
        endIf
      endForEach

      return text

endClass


class Command
  PROPERTIES
    icom     : ImageCompiler
    filepath : String
    line     : Int32
    content  : String
    reader   : ParseReader
    buffer   = StringBuilder()

  METHODS
    method init( icom, filepath, line, content )
      reader = ParseReader( content )

    method consume( ch:Character )->Logical
      return (reader.consume(ch))

    method consume( text:String )->Logical
      return (reader.consume(text))

    method consume_whitespace->Logical
      local found_any = false

      while (reader.consume_spaces or reader.consume('\t'))
        found_any = true
      endWhile

      return found_any

    method error( message:String )->BuildError
      return BuildError( this, message )

    method execute
      if (consume("@"))
        local pattern = parse_string( "Filename or file pattern expected after \"@\"." )
        trace pattern
      endIf

    method has_another->Logical
      consume_whitespace
      return (reader.has_another)

    method must_consume( ch:Character )->Logical
      if (consume(ch)) return true

      if (reader.has_another)
        throw error( ''Syntax error - expected "$", found "$".'' (ch,reader.peek) )
      else
        throw error( ''Syntax error - expected "$", found [end of line].'' (ch) )
      endIf

    method must_consume( text:String )->Logical
      if (consume(text)) return true

      if (reader.has_another)
        throw error( ''Syntax error - expected "$", found "$".'' (text,reader.peek) )
      else
        throw error( ''Syntax error - expected "$", found [end of line].'' (text) )
      endIf

    method parse_string( expected:String )->String
      if (not has_another) throw error( expected )
      buffer.clear
      while (reader.has_another)
        local ch = reader.peek
        if (ch == ' ') escapeWhile
        buffer.print reader.read
      endWhile
      if (buffer.count == 0) throw error( expected )
      return buffer->String

    method to->String
      return content
endClass


#{
class Commands
  PROPERTIES
    reader   : LineReader
    buffer   = StringBuilder()
    next_cmd : Cmd

  METHODS
    method init( file:File )
      reader = LineReader( file )
      if (reader.has_another)

      #{
    method consume_whitespace->Logical
      local found_any = false
      while (reader.has_another)
        contingent
          sufficient (reader.consume_spaces)
          sufficient (reader.consume_eols)
          sufficient (reader.consume('\t'))
          if (reader.consume('#'))
            while (reader.has_another and reader.peek != '\n') reader.read
            sufficient
          endIf
          return found_any

        satisfied
          found_any = true

        endContingent
      endWhile
      }#

    method has_another->Logical
      consume_whitespace
      return reader.has_another

    method parse_text->String
      consume_whitespace
      if (not reader.has_another) return ""

      buffer.clear
      local ch = reader.read
      buffer.print ch
      while (reader.has_another)
        local ch = reader.peek
        if (ch == ' ' or ch == '\n')

endClass

}#
