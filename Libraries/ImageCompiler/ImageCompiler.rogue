$include "../Rogue/Plasmacore"
using Plasmacore

try
  local config_file = File( "Assets/Images/ImageConfig.txt" )
  if (not config_file.exists)
    File.create_folder( config_file.path )
    local writer = PrintWriter(config_file.writer)
    writer.println @|# Default config file - customize as desired.
                    |[Global]
                    |@ **/*Font* varfont
                    |@ **/*font* varfont
                    |
                    |[Default]
                    |imageSheetSize 2048
                    |group *
    writer.close
  endIf



  local args = System.command_line_arguments
  if (args.count)
    ImageCompiler( config_file, (forEach in args) )
  else
    ImageCompiler( config_file, "Default" )
  endIf

catch (err:BuildError)
  println err
  System.exit 1
endTry

class Bitmaps : Table<<String,Bitmap>> [singleton]
  METHODS
    method get( name:String )->Bitmap
      local bitmap = prior.get( name )
      if (bitmap) return bitmap

      bitmap = Bitmap( File(name) )
      this[ name ] = bitmap

      return bitmap
endClass

class BuildError( cmd:Command, message ) : Error
  METHODS
    method init( message )

    method to->String
      local builder = StringBuilder()

      local bar = "=" * Console.width.or_smaller( 79 )
      builder.println bar
      if (cmd)
        builder.println( (''IMAGE COMPILE ERROR in "$" line $'' (cmd.src_filepath,cmd.src_line)).word_wrapped(Console.width) )
      else
        builder.println "IMAGE COMPILE ERROR"
      endIf
      builder.println
      builder.println message.word_wrapped( Console.width )
      builder.println bar
      return builder->String
endClass

class ImageCompiler
  PROPERTIES
    file             : File
    file_timestamp   : Real64
    platform         : String
    commands         = Table<<String,Command[]>>()
    attributes       = @[]
    settings         = @{}
    image_sheet_size = 2048

  METHODS
    method init( file, platform )
      file_timestamp = file.timestamp
      organize_commands
      execute_global_commands
      execute_platform_commands

    method execute_global_commands
      if (not commands.contains("Global")) return
      (forEach in commands//Global).execute

    method execute_platform_commands
      local working_platform = select{ commands.contains(platform):platform || "Default" }
      if (commands.contains(working_platform))
        (forEach in commands[working_platform]).execute
      else
        if (platform != "Default")
          println "IMAGE COMPILER WARNING: No configuration for platforms $ or Default in Assets/Images/ImageConfig.txt." (platform)
        else
          println "IMAGE COMPILER WARNING: No configuration for platform Default in Assets/Images/ImageConfig.txt."
        endIf
      endIf

    method organize_commands
      local category = "Global"
      forEach (line at index in LineReader(file))
        line = strip_comments( line.trimmed )
        if (line.count == 0) nextIteration
        if (line.begins_with('['))
          local after = line.after_first(']')
          if (after.count) throw BuildError( Command(this,file.filepath,index+1,line), "Syntax error after ']'." )
          category = line.after_first( '[' ).before_first( ']' ).trimmed
        else
          ensure commands[ category ]
          commands[ category ].add( Command(this,file.filepath,index+1,line) )
        endIf
      endForEach

    method strip_comments( text:String )->String
      if (not text.contains('#')) return text

      local in_string   = 0
      local ignore_next = false
      forEach (ch at index in text)
        if (ignore_next)
          ignore_next = false
        else
          if (in_string)
            which (ch)
              case '\\':      ignore_next = true
              case in_string: in_string = 0
            endWhich
          else
            which (ch)
              case '"', '\'': in_string = ch
              case '#': return text.leftmost( index )
            endWhich
          endIf
        endIf
      endForEach

      return text

endClass


class Command
  PROPERTIES
    icom         : ImageCompiler
    src_filepath : String
    src_line     : Int32
    content      : String
    reader       : ParseReader
    buffer       = StringBuilder()

  METHODS
    method init( icom, src_filepath, src_line, content )
      reader = ParseReader( content )

    method collect_files( filepath:String )->String[]
      local pattern = filepath
      if (File.exists(filepath))
        pattern = "**"
      else
        while (filepath.contains('*') or filepath.contains('?')) filepath = File.folder( filepath )
        if (not File.exists(filepath)) throw error( ''No such file or folder "$".'' (filepath) )
      endIf

      local file_list = String[]

      if (File.is_folder(filepath))
        forEach (f in File.listing(filepath,&ignore_hidden,&recursive))
          if (File.matches_wildcard_pattern(f,pattern)) file_list.add( f )
        endForEach
      else
        file_list.add( filepath )
      endIf

      # Filter files
      # TODO

      return file_list

    method consume( ch:Character )->Logical
      return (reader.consume(ch))

    method consume( text:String )->Logical
      return (reader.consume(text))

    method consume_whitespace->Logical
      local found_any = false

      while (reader.consume_spaces or reader.consume('\t'))
        found_any = true
      endWhile

      return found_any

    method error( message:String )->BuildError
      return BuildError( this, message )

    method execute
      if (consume("@"))
        local pattern = parse_string( "Filename or file pattern expected after \"@\"." )
        local info = @{ pattern:pattern, attributes:[] }
        while (has_another)
          local name = parse_string( "Attribute or [end of line] expected." )
          local attribute = @{ name:name }
          consume_whitespace
          if (consume(':'))
            attribute//value = parse_string( "Value expected." )
          endIf
          info//attributes.add( attribute )
        endWhile
        icom.attributes.add( info )
        return
      endIf

      local cmd = parse_string( "Command expected." )
      which (cmd)
        case "group"
          create_group

        case "image_copy"
          local args = parse_args
          require_arg( args, "from" )
          require_arg( args, "to" )
          image_copy( args )

        case "set"
          local setting = parse_name_value
          icom.settings[ setting//name ] = setting//value

        others
          trace "TODO ", cmd
      endWhich

    method create_group
      local pattern = "Assets/Images/" + parse_string( "File pattern expected." )
      #local args = parse_args
trace pattern
      local files = collect_files( pattern )
trace (forEach in files)

    method has_another->Logical
      consume_whitespace
      return (reader.has_another)

    method image_copy( args:@{} )
      require_arg( args, "from" )
      require_arg( args, "to" )
      local from_filepath = args//from->String
      local to_filepath   = args//to->String
      if (not from_filepath.begins_with("Assets/Images/")) from_filepath = "Assets/Images/" + from_filepath
      if (not to_filepath.begins_with("Assets/Images/"))   to_filepath = "Assets/Images/" + to_filepath

      local files = collect_files( from_filepath )
      forEach (src_filepath in files)
        local from_folder = from_filepath
        if (from_folder.contains('*') or from_folder.contains('?'))
          from_folder = File.folder( from_folder, &omit_wildcard_pattern )
        endIf

        local dest_filepath = to_filepath + src_filepath.after_first( from_folder )
        local ext = src_filepath.after_last( "." ).to_lowercase

        contingent
          necessary  (not File.is_folder(src_filepath))
          necessary  (ext == "png" or ext == "jpeg" or ext == "jpg")
          sufficient (not File.exists(dest_filepath))

          necessary  (not args//missing_only)
          local dest_timestamp = File.timestamp( dest_filepath )
          local src_timestamp = File.timestamp( src_filepath )
          sufficient (src_timestamp > dest_timestamp)
          sufficient (icom.file_timestamp > dest_timestamp)

          escapeContingent

        satisfied
          image_copy( src_filepath, dest_filepath, args )

        endContingent
      endForEach

    method image_copy( from_filepath:String, to_filepath:String, args:Value )
      local attributes = @{}
      forEach (attr in icom.attributes)
        if (File.matches_wildcard_pattern(from_filepath,attr//pattern))
          forEach (a in attr//attributes)
            if (a//value) attributes[ a//name ]         = a//value
            else          attributes[ a//name->String ] = true
          endForEach
        endIf
      endForEach

      println "Image Copy $ -> $" (from_filepath.after_first("Assets/Images/"),to_filepath.after_first("Assets/Images/"))

      local scale = parse_scale( args//rescale )
      local resize_ipad = (args//resize == "ipad_pro_to_retina")
      if (resize_ipad) scale = 0.75

      if (scale == 1.0)
        File.copy( from_filepath, to_filepath )
      else
        local bitmap = Bitmaps[ from_filepath ]
        local w = bitmap.width
        local h = bitmap.height

        if (attributes//varfont)
          local characters = extract_varfont_characters( bitmap )
          print "  # character".pluralized( characters.count )
          print " [$x$] -> " (w,h)
          forEach (ch in characters) ch.resize( ch.width*scale, ch.height*scale )
          bitmap = pack_varfont_characters( characters )
          println " [$x$]" (bitmap.width,bitmap.height)
          save_bitmap( bitmap, to_filepath )

        elseIf (attributes//split)
          local size = parse_dimensions( attributes//split )
          local tiles_wide = size//width->Int32
          local tiles_high = size//height->Int32
          local tiles = bitmap_to_tiles( bitmap, tiles_wide, tiles_high )
          print "  $x$ tiles" (tiles_wide,tiles_high)
          print " [$x$] -> " (w,h)
          forEach (tile in tiles) tile.resize( tile.width*scale, tile.height*scale )
          bitmap = tiles_to_bitmap( tiles, tiles_wide, tiles_high )
          println " [$x$]" (bitmap.width,bitmap.height)
          save_bitmap( bitmap, to_filepath )

        else
          local new_w = (w * scale)->Int32
          local new_h = (h * scale)->Int32
          if (resize_ipad)
            if (w == 2732 and h == 2048)     new_w = 2048; new_h = 1536
            elseIf (w == 2048 and h == 2732) new_w = 1536; new_h = 2048
          endIf
          bitmap.resize( new_w, new_h )
          println "  [$x$] -> [$x$]" (w,h,bitmap.width,bitmap.height)

          save_bitmap( bitmap, to_filepath )
        endIf
      endIf

    method bitmap_to_tiles( bitmap:Bitmap, tiles_wide:Int32, tiles_high:Int32 )->Bitmap[]
      local tiles = Bitmap[]
      local w = bitmap.width / tiles_wide
      local h = bitmap.height / tiles_high
      forEach (j in 0..<tiles_high)
        forEach (i in 0..<tiles_wide)
          tiles.add( Bitmap(bitmap,Box(i*w,j*h,w,h)) )
        endForEach
      endForEach
      return tiles

    method tiles_to_bitmap( tiles:Bitmap[], tiles_wide:Int32, tiles_high:Int32 )->Bitmap
      require (tiles.count == tiles_wide * tiles_high)
      local w = tiles.first.width
      local h = tiles.first.height
      local bitmap = Bitmap( w*tiles_wide, h*tiles_high )
      forEach (j in 0..<tiles_high)
        forEach (i in 0..<tiles_wide)
          tiles[ j*tiles_wide + i ].blit( bitmap, XY(i*w,j*h) )
        endForEach
      endForEach
      return bitmap

    method extract_varfont_characters( bitmap:Bitmap )->Bitmap[]
      local characters = Bitmap[]
      local x1 = 0
      local w  = bitmap.width
      local char_height = bitmap.height - 1

      while (x1 < w)
        local color = bitmap.get( x1, 0 )
        local x_limit = x1 + 1
        while (x_limit < w and bitmap.get(x_limit,0) == color) ++x_limit
        characters.add( Bitmap(bitmap,Box(x1,1,x_limit-x1,char_height)) )
        x1 = x_limit
      endWhile

      return characters

    method pack_varfont_characters( characters:Bitmap[] )->Bitmap
      require characters.count
      local total_w = 0
      total_w += (forEach in characters).width
      local bitmap = Bitmap( total_w, characters.first.height + 1 )
      local color = Color.RED
      local x = 0
      forEach (ch in characters)
        bitmap.fill( Box(x,0,ch.width,1), color )
        ch.blit( bitmap, XY(x,1) )
        if (color == Color.RED) color = 0xFF00FF00
        else                    color = Color.RED
        x += ch.width
      endForEach
      return bitmap

    method save_bitmap( bitmap:Bitmap, to_filepath:String )
      local is_png = true
      local lc = to_filepath.to_lowercase
      if (lc.ends_with(".jpg") or lc.ends_with(".jpeg")) is_png = false

      File.create_folder( File.folder(to_filepath) )
      if (is_png)
        File.save( to_filepath, bitmap.to_png_bytes )
      else
        File.save( to_filepath, bitmap.to_jpeg_bytes )
      endIf


    method must_consume( ch:Character )->Logical
      if (consume(ch)) return true

      if (reader.has_another)
        throw error( ''Syntax error - expected "$", found "$".'' (ch,reader.peek) )
      else
        throw error( ''Syntax error - expected "$", found [end of line].'' (ch) )
      endIf

    method must_consume( text:String )->Logical
      if (consume(text)) return true

      if (reader.has_another)
        throw error( ''Syntax error - expected "$", found "$".'' (text,reader.peek) )
      else
        throw error( ''Syntax error - expected "$", found [end of line].'' (text) )
      endIf

    method parse_args->@{}
      local args = @{}
      while (has_another)
        local arg = parse_name_value
        if (arg//value) args[ arg//name ]         = arg//value
        else            args[ arg//name->String ] = true
      endWhile
      return args

    method parse_name_value->Value
      local name = parse_string( "Identifier or [end of line] expected." )
      local name_value = @{ name:name }
      consume_whitespace
      if (consume(':'))
        name_value//value = parse_string( "Value expected." )
      endIf
      return name_value

    method parse_dimensions( text:String )->Value
      local dims = text.split( "x" )
      if (not dims.count)  throw error( ''Expected <width>x<height>, found "$".'' (text) )
      if (dims.count == 1)
        local size = dims.first->Int32
        return @{ width:size, height:size }
      else
        return @{ width:dims[0]->Int32, height:dims[1]->Int32 }
      endIf

    method parse_scale( text:String )->Real64
      if (text.count == 0) return 1.0
      if (not text.contains('/')) return text->Real64
      local parts = text.split( "/" )
      return parts[0]->Real64 / parts[1]->Real64

    method parse_string( expected:String )->String
      if (not has_another) throw error( expected )
      buffer.clear
      local ch = reader.peek
      if (ch == '"' or ch == '\'')
        # Quote-delimited
        local quote_type = reader.read
        while (reader.has_another)
          ch = reader.read
          which (ch)
            case quote_type: return buffer->String
            case '\\'
              if (reader.has_another) buffer.print( reader.read )
            others
              buffer.print( ch )
          endWhich
        endWhile
        throw error( "String is missing closing ($)." (quote_type) )
      else
        while (reader.has_another)
          ch = reader.peek
          which (ch)
            case ' ', ':', ','
              escapeWhile
            others
              buffer.print reader.read
          endWhich
        endWhile
        if (buffer.count == 0) throw error( expected )
      endIf
      return buffer->String

    method require_arg( args:@{}, name:String  )
      if (not args.contains(name)) throw error( "Missing required argument '$'." (name) )

    method to->String
      return content
endClass


#{
class Commands
  PROPERTIES
    reader   : LineReader
    buffer   = StringBuilder()
    next_cmd : Cmd

  METHODS
    method init( file:File )
      reader = LineReader( file )
      if (reader.has_another)

      #{
    method consume_whitespace->Logical
      local found_any = false
      while (reader.has_another)
        contingent
          sufficient (reader.consume_spaces)
          sufficient (reader.consume_eols)
          sufficient (reader.consume('\t'))
          if (reader.consume('#'))
            while (reader.has_another and reader.peek != '\n') reader.read
            sufficient
          endIf
          return found_any

        satisfied
          found_any = true

        endContingent
      endWhile
      }#

    method has_another->Logical
      consume_whitespace
      return reader.has_another

    method parse_text->String
      consume_whitespace
      if (not reader.has_another) return ""

      buffer.clear
      local ch = reader.read
      buffer.print ch
      while (reader.has_another)
        local ch = reader.peek
        if (ch == ' ' or ch == '\n')

endClass

}#
