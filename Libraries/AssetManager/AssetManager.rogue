$include "../Rogue/Plasmacore"
using Plasmacore

global help = @{}
help//displayconfig = "Configure Displays"
help//cd            = "Change Directory"
help//ls            = "List Directory"
help//platform      = "Change Platform"
help//cloneplatform = "Clone Platform"
help//rmplatform    = "Remove Platform"
help//all           = "List All - list all groups and assets in current platform."
help//mkgroup       = "Make Group - turn current directory and all the files it contains into a new asset group."
help//clonegroup    = "Clone Group - Clones the current group to a new group name or multiple matching groups and files matching a string using a replacement string."
help//clonegroups   = "Clone Groups"
help//add           = "Add to Group - add all files or selected files in current directory to current asset group."
help//inventory     = "Inventory - list files added to current asset group."
help//view          = "View Assets"
help//x             = "Examine - adjust the properties of an individual asset."
help//rm            = "Remove Assets - remove selected assets from current group."
help//compile       = "Compile Group"
help//group         = "Change Group"
help//sheetsize     = "Sheet Size - change the maximum image sheet size"
help//rmgroup       = "Remove Group"
help//undo          = "Undo last change"
help//update        = "Update - if any group name mirrors an Assets/Images/ folder name, adds any new files to that group that don't already appear in the inventory."
help//untracked     = "Untracked - list any files that aren't part of any group."

#Console.immediate_input = true

local args = System.command_line_arguments
if (args.count > 2 or (args.count >= 1 and not "compile".begins_with(args[0])))
  println "ERROR: Unsupported command line option: " + args[0]
  println @|
           |USAGE
           |  am [compile [<Platform>]]
  System.exit 1
endIf

try
  AssetManager.execute
catch (err:Error)
  println err
  System.exit 1
endTry

routine scale_string_to_value( scale_string:String )->Real64
  if (scale_string.contains('/'))
    local dims = scale_string.split( '/' )
    if (dims.count != 2)
      println "Syntax error in fraction: $." (scale_string)
      return 1.0
    endIf
    return dims[0]->Real64 / dims[1]->Real64
  else
    return scale_string->Real64
  endIf
endRoutine

class SavedState( cmd:String, inventory:String, config:String );

class AssetManager [singleton]
  PROPERTIES
    config_file = File( ".am.config.local" )
    inventory_file = File( "Assets/Inventory.json" )
    absolute_base_folder : String
    base_folder = "Assets"
    cur_build_folder : String
    cur_folder   : String
    args = String[]

    platform_names = String[]
    group_names    = String[]

    cur_platform_name : String
    cur_group_name    : String

    cur_platform : @{}
    cur_group    : @{}

    config    : Value
    inventory : Value

    menu = Menu()

    undo_stack = SavedState[]
    redo_stack = String[]

    bitmap_cache = Table<<String,Bitmap>>()

  METHODS
    method execute
      load

      local args = System.command_line_arguments
      if (args.count)
        # We know args[0] is "compile"
        if (args.count == 2)
          compile_platform( args[1] )
        else
          println "Compiling all platforms..."
          forEach (name in platform_names)
            if (not compile_platform( name ))
              println "Aborting compile."
              escapeForEach
            endIf
          endForEach
        endIf
        println "Done."
      else
        AssetManager.interactive_mode
      endIf

      save

    method compile_platform( platform_name:String )->Logical
      if (not platform_names.contains(platform_name))
        println ''Asset Manager: Platform "$" is not defined; creating empty platform.'' (platform_name)
        change_platform( platform_name )
      endIf

      println "Compiling $ assets..." (platform_name)

      local manifest = @{ groups:[] }

      local newest_timestamp = 0.0
      change_platform( platform_name )
      forEach (group_name in group_names)
        compile( group_name )
        manifest//groups.add( cur_group//cache//manifest )
        newest_timestamp = newest_timestamp.or_larger( cur_group//timestamp->Real64 )
      endForEach

      local manifest_filepath = cur_build_folder + "Assets/Images/ImageManifest.json"
      if (not File.exists(manifest_filepath) or File.timestamp(manifest_filepath) < newest_timestamp)
        println "  Writing $..." (manifest_filepath)
        manifest.save( File(manifest_filepath), &formatted )
      endIf

      if (cur_platform_name == "iOS")
        compile_ios_icons
      endIf

      return true

    method compile_ios_icons
      local square_bitmaps = Bitmap[]
      if (File.exists("Assets/Icons/iOS"))
        forEach (filename in File.listing("Assets/Icons/iOS"))
          local lc = filename.to_lowercase
          if (lc.ends_with(".png") or lc.ends_with(".jpg"))
            local bitmap = Bitmap( File(filename) )
            if (not bitmap.error)
              if (bitmap.width == bitmap.height)
                square_bitmaps.expand_to_include( bitmap.size.x )[ bitmap.size.x ] = bitmap
              endIf
            endIf
          endIf
        endForEach
      endIf

      if (square_bitmaps.count == 0) return

      File.create_folder( "Build/iOS/Icons" )
      generate_icon( square_bitmaps, 20, 20, (forEach in 1..3) )
      generate_icon( square_bitmaps, 29, 29, (forEach in 1..3) )
      generate_icon( square_bitmaps, 40, 40, (forEach in 1..3) )
      generate_icon( square_bitmaps, 50, 50, (forEach in 1..2) )
      generate_icon( square_bitmaps, 57, 57, (forEach in 1..2) )
      generate_icon( square_bitmaps, 60, 60, (forEach in 2..3) )
      generate_icon( square_bitmaps, 72, 72, (forEach in 1..2) )
      generate_icon( square_bitmaps, 76, 76, (forEach in 1..2) )
      generate_icon( square_bitmaps, 83.5, 83.5, 2 )

    method generate_icon( sizes:Bitmap[], w:Real64, h:Real64, density:Int32 )
      local ws = select{ w==w.floor:w->Int32->String || w->String }
      local hs = select{ h==h.floor:h->Int32->String || h->String }
      local filepath = "Build/iOS/Icons/Icon-$x$@$x.png" (ws,hs,density)

      local bitmap : Bitmap
      forEach (i in (w*density)->Int32..<sizes.count)
        bitmap = sizes[i]
        if (bitmap) escapeForEach
      endForEach

      if (not bitmap)
        forEach (i in (w*density)->Int32 downTo 0)
          bitmap = sizes[i]
          if (bitmap) escapeForEach
        endForEach
      endIf

      if (not File.exists(filepath) or File.timestamp(filepath) < File.timestamp(bitmap.filepath))
        local pixel_w = (w * density)->Int32
        local pixel_h = (h * density)->Int32
        println "  Writing $ [$x$]" (filepath,pixel_w,pixel_h)
        File.save( filepath, bitmap.resized(pixel_w,pixel_h).to_png_bytes )
      endIf

    method load
      File.create_folder( base_folder + "/Images" )
      cur_folder = base_folder
      absolute_base_folder = File.absolute_filepath( base_folder )

      load_inventory_file
      load_config

    method save
      save_config
      save_inventory_file

    method interactive_mode
      if (config//help_text_shown)
        println "ASSET MANAGER"
        println "Enter '?' for help or 'q' to quit."
      else
        config//help_text_shown = true
        display_help
      endIf

      while (menu.present) noAction

    method change_directory( relative_path:String )
      #println "Change directory " + relative_path
      local new_folder = "$/$" (cur_folder,relative_path)
      if (not File.exists(new_folder))
        println "ERROR: Folder does not exist!"
        return
      endIf
      if (not File.is_folder(new_folder))
        println "ERROR: $ is not a folder!" (new_folder)
        return
      endIf

      new_folder = File.absolute_filepath( new_folder )

      if (not new_folder.begins_with(absolute_base_folder))
        println "Folder must be a subfolder of Assets/."
        return
      endIf

      new_folder = base_folder + new_folder.rightmost( -absolute_base_folder.count )
      cur_folder = new_folder
      config//cur_folder = new_folder

    method current_group_contains_asset( filepath:String )->Logical
      if (not cur_group) return false
      return group_contains_asset( cur_group, filepath )

    method any_group_contains_asset( filepath:String )->Logical
      if (not cur_platform) return false
      forEach (group_name in group_names)
        if (group_contains_asset( cur_platform//groups[group_name], filepath )) return true
      endForEach
      return false

    method group_contains_asset( group:Value, filepath:String )->Logical
      return group//assets.contains( filepath )

    method print_asset( prefix:String, asset_name:String )
      print prefix
      print ' '
      print short_asset_name( asset_name )
      #{
      print " ["
      local asset = update_asset_info( asset_name )
      if (asset//info//exists)
        if (asset//width)
          print asset//width
          print 'x'
          print asset//height
        endIf
      else
        print "missing file"
      endIf
      println "]"
      }#
      println

    method print_filepath( filepath:String )
      local full_filepath = "$/$" (cur_folder,filepath)
      local is_folder = File.is_folder( full_filepath )
      if (current_group_contains_asset(full_filepath))
        print " +"
      elseIf (any_group_contains_asset(full_filepath))
        print " *"
      elseIf (is_folder)
        local is_group = false
        forEach (name in group_names)
          if (name == short_asset_name(full_filepath)) is_group = true; escapeForEach
        endForEach

        if (is_group) print " :"
        else          print "  "
      else
        print "  "
      endIf

      if (is_folder)
        print filepath
        print '/'
      else
        print filepath
      endIf

    method print_listing( ls_args=null:String )
      local folder = cur_folder
      local prefix = ""
      if (ls_args)
        while (ls_args.contains('/'))
          if (not ls_args.contains('*') or ls_args.locate('*').value > ls_args.locate('/').value)
            local part = ls_args.before_first( '/' )
            prefix += part + "/"
            folder += "/" + part
            ls_args = ls_args.after_first( '/' )
          else
            escapeWhile
          endIf
        endWhile
      endIf

      if (ls_args and File.is_folder(folder+"/"+ls_args))
        folder += "/" + ls_args
        prefix = ls_args + "/"
        ls_args = null
      endIf

      local listing : String[]
      local is_recursive = ls_args and ls_args.contains("**")

      if (ls_args)
        listing = File.listing( folder, &recursive=is_recursive, &ignore_hidden, &omit_path )
        forEach (filepath in rewriter=listing.rewriter)
          if (filepath.matches_wildcard_pattern(ls_args)) rewriter.write( filepath )
        endForEach
      else
        listing = File.listing( folder, &ignore_hidden, &omit_path )
      endIf

      forEach (filepath in listing)
        print_filepath( prefix + filepath )
        println
      endForEach

    method clone_platform( new_name:String )
      if (platform_names.contains(new_name))
        println "ERROR: platform $ already exists." (new_name)
        return
      endIf

      platform_names.add( new_name )
      inventory//platforms[ new_name ] = cur_platform.cloned
      change_platform( new_name )
      cur_platform//name = new_name

    method clone_group( new_name:String )
      if (group_names.contains(new_name))
        println "ERROR: group $ already exists." (new_name)
        return
      endIf

      group_names.add( new_name )
      cur_platform//groups[ new_name ] = cur_group.cloned
      change_group( new_name )
      cur_group//name = new_name
      AssetManager.mark_group_modified

    method clone_groups( search_string:String, replace_string:String )
      forEach (group_name in group_names.cloned)
        if (group_name.contains(search_string))
          local new_group_name = group_name.replacing( search_string, replace_string )
          if (not group_names.contains(new_group_name))
            println "Cloning $ -> $" (group_name,new_group_name)
            change_group( group_name )
            clone_group( new_group_name )

            # Perform search and replace on all asset names
            forEach (key in cur_group//assets.keys)
              local asset = cur_group//assets[ key ]
              local asset_name = asset//filepath->String
              if (asset_name.contains(search_string))
                local new_asset_name = asset_name.replacing( search_string, replace_string )
                if (not cur_group//assets.contains(new_asset_name))
                  println "Renaming asset $ -> $" (short_asset_name(asset_name),short_asset_name(new_asset_name))
                  asset//filepath = new_asset_name
                  cur_group//assets[ new_asset_name ] = cur_group//assets.remove( asset_name )
                endIf
              endIf
            endForEach
          endIf
        endIf
      endForEach

      #{
    method clone_groups( search_string:String, replace_string:String, scale_string:String )
      forEach (group_name in group_names.cloned)
        if (group_name.contains(search_string))
          local new_group_name = group_name.replacing( search_string, replace_string )
          if (not group_names.contains(new_group_name))
            println "Cloning $ -> $" (group_name,new_group_name)
            change_group( group_name )
            clone_group( new_group_name )

            if (scale_string)
              # Apply a scale operation to all assets
              forEach (asset in cur_group//assets)
                local s = scale_string_to_value( scale_string )
                asset.ensure_list( "operations" ).add( @{name:"rescale",scale:s,label:"scale $"(scale_string)} )
              endForEach
            else
              # Perform search and replace on all asset names
              forEach (key in cur_group//assets.keys)
                local asset = cur_group//assets[ key ]
                local asset_name = asset//filepath->String
                if (asset_name.contains(search_string))
                  local new_asset_name = asset_name.replacing( search_string, replace_string )
                  if (not cur_group//assets.contains(new_asset_name))
                    println "Renaming asset $ -> $" (short_asset_name(asset_name),short_asset_name(new_asset_name))
                    asset//filepath = new_asset_name
                    cur_group//assets[ new_asset_name ] = cur_group//assets.remove( asset_name )
                  endIf
                endIf
              endForEach
            endIf
          endIf
        endIf
      endForEach
      }#

    method short_asset_name( name:String )->String
      return name.after_first( "Assets/" ).after_any( "Images/" )

    method add_files( folder:String, filepaths:String[] )
      forEach (filepath in filepaths)
        add_file( folder + "/" + filepath )
      endForEach

    method add_file( filepath:String )
      cur_group.ensure_table( "assets" )
      if (not cur_group//assets.contains( filepath ))
        println "Adding " + filepath
        AssetManager.mark_group_modified
        cur_group//assets[ filepath ] = @{ filepath:filepath }

        if (cur_group//type == "Unknown")
          if (filepath.begins_with("Assets/Images"))
            cur_group//type = "Images"
          else
            cur_group//type = "Assets"
          endIf
        endIf
      endIf

    method remove_files( filepaths:String[] )
      forEach (filepath in filepaths)
        remove_file( filepath )
      endForEach

    method remove_file( filepath:String )
      filepath = "Assets/$/$" (cur_group//type,filepath)
      if (cur_group//assets.contains( filepath ) )
        println "Removing " + filepath
        AssetManager.mark_group_modified
        cur_group//assets.remove( filepath )
      endIf

    method asset_list( filter=null:String )->Value
      local list = cur_group//assets.values
      if (filter) list = list[ //filepath->String.matches_wildcard_pattern(filter) ]
      return list

    method change_platform( cur_platform_name )
      config//cur_platform_name = cur_platform_name
      if (cur_platform_name)
        if (not platform_names.contains(cur_platform_name))
          platform_names.add( cur_platform_name )
          inventory//platforms[ cur_platform_name ] = @{ name:cur_platform_name }
        endIf
        cur_platform = inventory//platforms[ cur_platform_name ]
        cur_platform.ensure_table( "groups" )

        group_names.clear
        forEach (name in cur_platform//groups.keys)
          group_names.add( name )
        endForEach

        if (cur_group_name and group_names.contains(cur_group_name))
          change_group( cur_group_name )
        elseIf (group_names.count)
          change_group( group_names.first )
        else
          change_group( null )
        endIf

      else
        cur_platform = null
      endIf

      if (cur_platform_name)
        cur_build_folder = "Build/$/" (cur_platform_name)
        File.create_folder( cur_build_folder + "Assets/Images" )
      else
        cur_build_folder = null
      endIf

    method change_to_available_platform
      if (not cur_platform_name and platform_names.count)
        change_platform( platform_names.first )
      endIf

    method delete_platform( name:String )
      if (platform_names.contains(name))
        platform_names.remove( name )
        inventory//platforms.remove( name )
        if (name == cur_platform_name)
          cur_platform_name = null
          cur_platform = null
          cur_group = null
          cur_group_name = null
        endIf
      endIf

    method mark_group_modified
      cur_group//timestamp = System.time.floor
      cur_group.remove( "image_sheet_count" )

    method compile( group_name:String, &view_result )->Logical
      change_group( group_name )
      return ImageCompiler().compile( view_result )

    method change_group( cur_group_name )
      config//cur_group_name = cur_group_name

      if (not cur_group_name)
        cur_group = null
        return
      endIf

      if (not cur_platform_name)
        println "Create a platform first (e.g. 'platform iOS')."
        return
      endIf

      if (not group_names.contains(cur_group_name))
        group_names.add( cur_group_name )
        cur_platform//groups[ cur_group_name ] = @{name:cur_group_name,type:"Unknown"}
      endIf

      cur_group = cur_platform//groups[ cur_group_name ]

    method change_to_available_group
      if (not cur_group_name and group_names.count)
        change_group( group_names.first )
      endIf

    method delete_group( name:String )
      if (group_names.contains(name))
        group_names.remove( name )
        cur_platform//groups.remove( name )
        if (name == cur_group_name)
          cur_group_name = null
          cur_group = null
        endIf
      endIf

    method get_bitmap( filepath:String )->Bitmap
      local bitmap = bitmap_cache[ filepath ]
      if (bitmap) return bitmap

      bitmap = Bitmap( File(filepath) )
      if (bitmap.error)
        println "ERROR: unable to load bitmap $." (filepath)
        return null
      endIf
      bitmap_cache[ filepath ] = bitmap
      return bitmap

    method set_max_image_sheet_size( setting:String )
      if (setting.contains('\e')) return
      setting = setting.trimmed
      if (setting == "" or setting == "q") return

      local w, h : Int32
      local dims = setting.split( 'x' )
      w = dims[0]->Int32
      if (dims.count == 2) h = dims[1]->Int32
      else                 h = w

      w = w.or_larger(64).to_power_of_two
      h = h.or_larger(64).to_power_of_two

      println "> Sheet Size $x$" (w,h)
      if (cur_group.contains("max_image_sheet_width"))
        local old_w = cur_group//max_image_sheet_width->Int32
        local old_h = cur_group//max_image_sheet_height->Int32
        if (old_w != w or old_h != h)
          mark_group_modified
          println "Current group's maximum image sheet size changed from $x$ to $x$." (old_w,old_h,w,h)
        else
          println "Current group's maximum image sheet size set to $x$." (w,h)
        endIf
      else
        mark_group_modified
        println "Current group's maximum image sheet size changed from the default 2048x2048 to $x$." (w,h)
      endIf

      cur_group//max_image_sheet_width = w
      cur_group//max_image_sheet_height = h

    method load_config
      load_config( ValueTable.load( config_file ) )

    method load_config( config )
      if (config//cur_platform_name?) cur_platform_name = config//cur_platform_name->String
      else                            cur_platform_name = null

      if (config//cur_group_name?) cur_group_name = config//cur_group_name->String
      else                         cur_group_name = null

      if (cur_platform_name)
        change_platform( cur_platform_name )
      elseIf (inventory//platforms.count)
        change_platform( inventory//platforms.first//name )
      else
        change_platform( null )
      endIf

      if (config//cur_folder)
        cur_folder = File.absolute_filepath( config//cur_folder->String )
        if (not File.exists(cur_folder)) cur_folder = base_folder

        if (cur_folder.begins_with(absolute_base_folder))
          cur_folder = base_folder + cur_folder.rightmost( -absolute_base_folder.count )
        else
          cur_folder = base_folder
        endIf
      endIf

    method load_inventory_file
      load_inventory( ValueTable.load( inventory_file ) )

    method load_inventory( inventory )
      inventory.ensure_table( "platforms" )
      platform_names.clear
      forEach (name in inventory//platforms.keys)
        platform_names.add( name->String )
      endForEach

    method save_config
      #trace config
      if (ValueTable.load(config_file)->String != config->String)
        config.save( config_file, &formatted )
      endIf

    method save_inventory_file
      #trace inventory
      if (ValueTable.load(inventory_file)->String != inventory->String)
        inventory.save( inventory_file, &formatted )
      endIf

    method save_undo( cmd:String )
      undo_stack.add( SavedState(cmd, inventory.to_json, config.to_json) )

    method display_help( cmd=null:String )
      #{
      if (cmd and cmd.count)
        if (help.contains(cmd))
          println help[cmd]
        else
          println "No such command: " + cmd
        endIf
      else
        }#
        println @|ASSET MANAGER
                 |
                 |"am" is used to create GROUPS of assets for different PLATFORMS using FILES
                 |from Asset Manager's CURRENT FOLDER.
                 |
                 |The Asset Manager COMMAND PROMPT usually looks like this:
                 |
                 |[PlatformName::GroupName] Current/Folder>>
                 |
                 |The following commands manipulate the current platform, group, and folder.
                 |Only enough characters are required to avoid ambiguous commands; for example
                 |"co" is sufficient for "compile" and "i" for "inventory".
                 |
                 |Most commands require arguments but you can enter the command by itself to see
                 |what arguments it accepts.  When you enter commands this way the possible
                 |options are shown numbered; you can enter a single number such as 5 or a range
                 |such as: 1 3-5 6-10.  You can also use the argument "." to mean the current
                 |platform/group/folder (example: "compile .").
                 |
                 |PLATFORM COMMANDS
                 |  platform <new platform name>
                 |    List existing platforms and/or change the current platform to a new or existing
                 |    platform.
                 |
                 |  cloneplatform <new platform name>
                 |    Creates a copy of the current platform.
                 |
                 |  displayconfig
                 |    Display target configuration sub-menu for the current platform.
                 |
                 |  all
                 |    List all groups and assets in current platform.
                 |
                 |  rmplatform
                 |    Deletes the current platform.
                 |
                 |  update
                 |    Adds new files to the appropriate group.  If any group name mirrors an
                 |    Assets/Images/ folder name, adds any new files to that group that haven't
                 |    already been added to the asset manager inventory.
                 |
                 |  untracked
                 |    Lists any image files that aren't part of any group.
                 |
                 |GROUP COMMANDS
                 |  group <group name>
                 |    List existing groups and/or change the current group to a new or existing
                 |    group.
                 |
                 |  clonegroup <new group name>
                 |    Creates a copy of the current group.
                 |
                 |  clonegroups <search text> <replace text>
                 |    Creates a copy of any group with a group name containing <search text>,
                 |    replacing <search text> in the group name and in all asset filepaths
                 |    with <replace text>.
                 |
                 |  add <files>
                 |    Add files from the current folder to the current group.  Use "*" to select
                 |    all files non-recursively or "**" to select all files recursively.
                 |
                 |  compile <groups>
                 |    Compiles the images of one or more groups.  "com ." will compile the
                 |    current group.
                 |
                 |  inventory
                 |    Show all assets that have been added to the current group.
                 |
                 |  x <asset>
                 |    Examine the specified asset, which allows you to apply some processing
                 |    commands to it.
                 |
                 |  sheetsize <pixel-size>
                 |  sheetsize <pixel-width>x<pixel-height>
                 |    Set the image sheet size for this group to the specified maximum value.
                 |    The default maximum is 2048x2048 pixels.  Compiled image sheets will
                 |    automatically made smaller than the maximum when possible.  Image sheet
                 |    sizes are always powers of two.
                 |
                 |  rm <assets>
                 |    Remove assets from the current group.  The corresponding physical file is
                 |    NOT deleted.
                 |
                 |  rmgroup <group>
                 |    Deletes the specified group.
                 |
                 |  view
                 |    Reveals this group's assets in a Finder window with Cover Flow.
                 |
                 |CURRENT FOLDER COMMANDS
                 |  cd <folder>
                 |    Change the location of the current folder.  Must be in the Assets/ project
                 |    subfolder.
                 |
                 |  ls [<filter>]
                 |    Lists all files in the current folder.  If a wildcard filter is supplied
                 |    ("ls *.png" or "ls **") then only files matching the filter will be listed.
                 |
                 |  mkgroup
                 |    Turn the current directory and all the files it contains into a new asset
                 |    group.  For example, "mkgroup" executed in the folder
                 |    "Assets/Images/Backgrounds" will create a new group called "Backgrounds".
                 |
                 |GENERAL COMMANDS
                 |  undo
                 |    Undo the last change.  There are unlimited undos until you exit the
                 |    Asset Manager.
                 |
                 |  q
                 |    Quit Asset Manager.
                 |
                 |  ?
                 |    Show this help text.
                 |


#endIf

endClass


class Menu
  PROPERTIES
    active_command        : String
    current_option        : String
    new_input_description : String
    command_options       = String[]
    user_choices          = String[]

  METHODS
    method present->Logical
      display
      #print "--- "
      if (active_command)
        print active_command
        print( " ...> " ).flush
      else

        if (AssetManager.cur_platform_name)
          print '['
          print AssetManager.cur_platform_name
          if (AssetManager.cur_group_name)
            print "::"
            print AssetManager.cur_group_name
          endIf
          print "] "
        endIf

        print AssetManager.cur_folder
        #{
        if (AssetManager.cur_folder.begins_with(AssetManager.base_folder))
          local rel_path = AssetManager.cur_folder.rightmost( -(AssetManager.base_folder.count) )
          if (rel_path.count == 0) rel_path = AssetManager.base_folder
          else                     rel_path = AssetManager.base_folder + rel_path
          print rel_path
        endIf
        }#

        print( ">> " ).flush
      endIf

      local input = Console.read_line
      if (input.contains('\e')) input = ""  # cancel anything with escape characters from arrow keys
      else                      input = input.trimmed

      if (input == "q" and not active_command)
        return false

      elseIf (input.begins_with('['))
        # Ex: [iOS] or [iOS::General]
        if (active_command)
          active_command = null
          return false
        endIf

        local cmd = input.after_first( '[' ).before_last( ']' )
        if (cmd.contains("::"))
          local platform = cmd.before_first( "::" )
          if (platform.count)
            println "> Platform " + platform
            AssetManager.change_platform( platform )
          endIf

          local group = cmd.after_first( "::" )
          if (group.count)
            println "> Group " + group
            AssetManager.change_group( group )
          endIf

        else
          println "> Platform " + cmd
          AssetManager.change_platform( cmd )
        endIf

      elseIf (input.begins_with('?') or input == "help")
        if (input == "?")
          AssetManager.display_help( active_command )
        else
          AssetManager.display_help( input.rightmost(-1).trimmed )
        endIf

      elseIf (input == "")
        if (active_command) active_command = null
        else println "(q)uit or (?) for help"

      elseIf (active_command)
        active_command = handle_command( active_command, input )

      else
        if (input.locate(' '))
          active_command = handle_command( input.before_first(' '),  input.after_first(' ').trimmed )
        else
          active_command = handle_command( input )
        endIf

      endIf

      return true

    method display

    method handle_command( cmd:String, args=null:String )->String
      if     ("add".begins_with(cmd) and cmd.count >= 2)           cmd = "add"
      elseIf ("all".begins_with(cmd) and cmd.count >= 2)           cmd = "all"
      elseIf ("cloneplatform".begins_with(cmd) and cmd.count >= 6) cmd = "cloneplatform"
      elseIf ("clonegroup".begins_with(cmd) and cmd.count >= 6)    cmd = "clonegroup"
      elseIf ("compile".begins_with(cmd) and cmd.count >= 2)       cmd = "compile"
      elseIf ("displayconfig".begins_with(cmd))                    cmd = "displayconfig"
      elseIf ("groups".begins_with(cmd))                           cmd = "group"
      elseIf ("inventory".begins_with(cmd))                        cmd = "inventory"
      elseIf ("mkgroup".begins_with(cmd))                          cmd = "mkgroup"
      elseIf ("platforms".begins_with(cmd))                        cmd = "platform"
      elseIf ("rmgroup".begins_with(cmd) and cmd.count >= 3)       cmd = "rmgroup"
      elseIf ("rmplatform".begins_with(cmd) and cmd.count >= 3)    cmd = "rmplatform"
      elseIf ("sheetsize".begins_with(cmd))                        cmd = "sheetsize"
      elseIf ("update".begins_with(cmd) and cmd.count >= 2)        cmd = "update"
      elseIf ("undo".begins_with(cmd) and cmd.count >= 3)          cmd = "undo"
      elseIf ("untracked".begins_with(cmd) and cmd.count >= 3)     cmd = "untracked"
      elseIf ("view".begins_with(cmd) and cmd.count >= 2)          cmd = "view"

      which (cmd)
        case "cloneplatform"
          if (args)
            AssetManager.save_undo( "$ $"(cmd,args) )
            println "> Clone Platform $ -> $" (AssetManager.cur_platform_name,args)
            AssetManager.clone_platform( args )
            return null
          elseIf (AssetManager.cur_platform)
            println "> Clone Platform " + AssetManager.cur_platform_name
            println "Enter new platform name"
            return "cloneplatform"
          else
            println "No platforms exist."
            return null
          endIf

        case "clonegroup", "clonegroups"
          if (args)
            AssetManager.save_undo( "$ $"(cmd,args) )
            if (args.contains(' '))
              local individual_args = args.split( ' ' )
              local search_string, replace_string : String
              local stage = 1
              forEach (arg in individual_args)
                if (arg.count)
                  which (stage)
                    case 1: search_string = arg.trimmed; ++stage
                    case 2: replace_string = arg.trimmed; ++stage
                    case 3
                      println "Too many arguments to $ - expected only 2." (cmd)
                      return null
                  endWhich
                endIf
              endForEach
              if (stage == 2)
                println "Not enough arguments to $ - expected 2." (cmd)
                return null
              endIf

              println "> Clone Groups *$* -> *$*" (search_string,replace_string)
              AssetManager.clone_groups( search_string, replace_string )
            else
              println "> Clone Group $ -> $" (AssetManager.cur_group_name,args)
              AssetManager.clone_group( args )
            endIf
            return null
          elseIf (AssetManager.cur_group)
            println "> Clone Group " + AssetManager.cur_group_name
            println "Enter new group name"
            return "clonegroup"
          else
            println "No groups exist."
            return null
          endIf

        case "cd"  # Change Directory
          local listing : String[]
          local is_number = args and args.count and args[0].is_number
          if (is_number) listing = get_listing( &folders )
          else           listing = get_listing( args, &recursive=(args?), &folders )
          if (AssetManager.cur_folder != AssetManager.base_folder) listing.add( ".." )
          configure_options( AssetManager.cur_folder, listing, args, null, "any relative path" )
          if (args)
            if (user_choices.count)
              AssetManager.save_undo( "$ $"(cmd,args) )
              println "> Change Directory $" (user_choices.first)
              AssetManager.change_directory( user_choices.first )
              AssetManager.print_listing
            endIf
            return null
          elseIf (display_options("Change Directory"))
            return cmd
          else
            println "No platforms exist."
            return null
          endIf

        case "displayconfig"
          if (not AssetManager.cur_platform_name)
            println "No platforms exist."
            return null
          endIf

          local substate = ConfigureDisplayTargets()
          while (substate) substate = substate.execute
          return null

        case "all"  # List All
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          println "> List All " + select{args||""}
          local original_group = AssetManager.cur_group_name
          forEach (g in AssetManager.group_names)
            println g
            AssetManager.change_group( g )

            local prefix = "Assets/$/" (AssetManager.cur_group//type->String)
            local list = AssetManager.asset_list( args )
            local w = Math.log10( list.count+1 ).ceiling->Int32
            forEach (asset at index in list)
              println "$ $" ((index+1).right_justified(w), asset//filepath->String.after_first( prefix ))
            endForEach

            println
          endForEach
          AssetManager.change_group( original_group )
          return null

        case "update"
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          AssetManager.save_undo( "update" )

          println "> Update Inventory"
          local original_group = AssetManager.cur_group_name
          local found_any = false
          forEach (g in AssetManager.group_names)
            AssetManager.change_group( g )

            local prefix = "Assets/$/" (AssetManager.cur_group//type->String)
            local folder = prefix + AssetManager.cur_group_name
            if (File(folder).exists)
              local first = true
              local listing = File.listing( folder, &recursive, &ignore_hidden )
              forEach (filepath in listing)
                if (not AssetManager.any_group_contains_asset(filepath))
                  if (first) println "Updating " + AssetManager.cur_group_name; first = false
                  print "  "
                  AssetManager.add_file( filepath )
                  found_any = true
                endIf
              endForEach
            endIf
          endForEach

          if (not found_any)
            println "All groups are up to date."
          endIf

          AssetManager.change_group( original_group )
          return null

        case "untracked"
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          local found_any = false

          println "> List Untracked Files"
          local listing = File.listing( "Assets/Images", &recursive, &ignore_hidden, &omit_path )
          forEach (filename in listing)
            local filepath = "Assets/Images/" + filename
            contingent
              necessary (not AssetManager.any_group_contains_asset(filepath))
              necessary (not File.is_folder(filepath))
              necessary (not File.filename(filename).begins_with('.'))
            satisfied
              found_any = true
              println filename
            endContingent
          endForEach

          if (not found_any)
            println "No untracked files."
          endIf

          return null

        case "ls"  # Listing
          println "> List " + select{args||""}
          AssetManager.print_listing( args )
          return null

        case "platform"  # Change Platform
          configure_options( AssetManager.cur_platform_name, AssetManager.platform_names, args, "platform", "new platform name" )
          if (args)
            if (user_choices.count)
              println "> Change Platform " + args
              AssetManager.save_undo( "$ $"(cmd,args) )
              AssetManager.change_platform( user_choices.first )
            endIf
            return null
          elseIf (display_options("Change Platform"))
            return cmd
          else
            println "No platforms exist."
            return null
          endIf

        case "rmplatform"  # Remove Platform
          configure_options( AssetManager.cur_platform_name, AssetManager.platform_names, args, "platform" )
          if (args)
            if (user_choices.count)
              AssetManager.save_undo( "$ $"(cmd,args) )
              forEach (platform in user_choices)
                println "> Remove Platform " + platform
                AssetManager.delete_platform( platform )
              endForEach
              if (AssetManager.platform_names.count)
                AssetManager.change_platform( AssetManager.platform_names.first )
              else
                AssetManager.change_platform( null )
              endIf
            endIf
            return null
          elseIf (display_options("Delete Platform"))
            return cmd
          else
            println "No platforms exist."
            return null
          endIf

        case "add"  # Add Files
          if (not AssetManager.cur_platform_name)
            println "ERROR: Create a platform first (e.g. 'platform iOS')."
            return null
          endIf

          if (not AssetManager.cur_group_name)
            println "ERROR: Create a group first (e.g. 'group General')."
            return null
          endIf

          local is_number = (args and args.count and args[0].is_number)
          local is_recursive = (is_number or args is null or args.contains("**"))
          local listing = get_listing( select{is_number:null||args}, &recursive=is_recursive )
          configure_options( null, listing, args )
          if (args)
            if (user_choices.count)
              AssetManager.save_undo( "$ $"(cmd,args) )
              println "> Add Files To Group"
              AssetManager.add_files( AssetManager.cur_folder, user_choices )
            endIf
            return null
          elseIf (display_options("Add Files To Group",&showing_files))
            return cmd
          else
            println "No files in current folder."
            return null
          endIf

        case "rm"  # Remove Assets From Group
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          if (not AssetManager.cur_group_name)
            println "No asset groups exist."
            return null
          endIf

          local is_number = args and args.count and args[0].is_number
          command_options.clear
          local group_type = AssetManager.cur_group//type->String + "/"
          forEach (asset in AssetManager.asset_list(select{is_number:null||args}))
            command_options.add( asset//filepath->String.after_first(group_type) )
          endForEach

          configure_options( null, command_options, args )
          if (args)
            if (user_choices.count)
              AssetManager.save_undo( "$ $"(cmd,args) )
              println "> Remove Assets From Group"
              AssetManager.remove_files( user_choices )
            endIf
            return null
          elseIf (display_options("Remove Assets From Group"))
            return cmd
          else
            println "No assets in group."
            return null
          endIf

          return null

        case "x"  # Examine Asset
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          if (not AssetManager.cur_group_name)
            println "No asset groups exist."
            return null
          endIf

          local is_number = args and args.count and args[0].is_number
          command_options.clear
          local group_type = "Assets/" + AssetManager.cur_group//type->String + "/"
          forEach (asset in AssetManager.asset_list(select{is_number:null||args}))
            command_options.add( asset//filepath->String.after_first(group_type) )
          endForEach

          configure_options( null, command_options, args )
          if (args)
            if (user_choices.count)
              AssetManager.save_undo( "$ $"(cmd,args) )
              println "> Examine Image Asset " + user_choices.first
              local ex = ExamineImageAsset( command_options.locate(user_choices.first).value, group_type + user_choices.first )
              while (ex) ex = ex.examine
            else
              println "> Examine Image Asset " + args
              println "ERROR: No such asset in current group."
            endIf
            return null
          elseIf (display_options("Examine Asset"))
            return cmd
          else
            println "No assets in group."
            return null
          endIf

          return null

        case "mkgroup"  # Make Group
          if (not AssetManager.cur_platform_name)
            println "ERROR: Create a platform first (e.g. 'platform iOS')."
            return null
          endIf

          if (AssetManager.cur_folder == AssetManager.base_folder)
            println "ERROR: cd to a subfolder before adding it as a group."
            return null
          endIf

          if (args)
            println "ERROR: mkgroup does not accept arguments."
            return null
          endIf

          local group_name = AssetManager.cur_folder
          local is_image_group = (group_name.begins_with("Assets/Images"))

          if (is_image_group)
            group_name = group_name.after_first( "Assets/Images/" )
            if (group_name == "") group_name = "Images"
          endIf

          if (AssetManager.group_names.contains(group_name))
            println 'ERROR: A group named "$" already exists.' (group_name)
            return null
          endIf

          AssetManager.save_undo( cmd )

          print "> Make "
          print select{ is_image_group:"Image " || "" }
          print "Group ["
          print AssetManager.cur_platform_name
          print "::"
          print group_name
          print "] "
          println select{args||""}

          AssetManager.change_group( group_name )
          AssetManager.cur_group//type = select{ is_image_group:"Images" || "Assets" }
          AssetManager.add_files( AssetManager.cur_folder, get_listing(&recursive) )
          return null

        case "inventory"  # Inventory
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          if (not AssetManager.cur_group_name)
            println "No asset groups exist."
            return null
          endIf

          local list = AssetManager.asset_list( args )
          local w = Math.log10( list.count+1 ).ceiling->Int32
          forEach (asset at index in list)
            AssetManager.print_asset( (index+1).right_justified(w), asset//filepath->String )
          endForEach

          return null

        case "compile"
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          if (not AssetManager.cur_group_name)
            println "No asset groups exist."
            return null
          endIf

          configure_options( AssetManager.cur_group_name, AssetManager.group_names, args, "group" )
          if (args)
            if (user_choices.count)
              println "> Compile # Group".pluralized( user_choices.count )
              AssetManager.save_undo( "$ $"(cmd,args) )
              local original_group_name = AssetManager.cur_group_name
              local compile_count = 0
              forEach (group_name in user_choices)
                if (AssetManager.compile(group_name,&view_result)) ++compile_count
              endForEach
              if (compile_count == 0) println "Group image sheets are up to date."
              AssetManager.change_group( original_group_name )
            endIf
            return null
          elseIf (display_options("Compile Group"))
            return cmd
          else
            println "No groups exist."
            return null
          endIf

        case "sheetsize"
          if (not AssetManager.cur_platform_name)
            println "No platforms or asset groups exist."
            return null
          endIf

          if (args)
            AssetManager.set_max_image_sheet_size( args )
          else
            println "> Sheet Size"
            if (AssetManager.cur_group.contains("max_image_sheet_width"))
              local cur_w = AssetManager.cur_group//max_image_sheet_width->Int32
              local cur_h = AssetManager.cur_group//max_image_sheet_height->Int32
              println "This asset group's maximum image sheet size is currently $x$." (cur_w,cur_h)
            else
              println "This asset group's maximum image sheet size is currently the default value of 2048x2048."
            endIf

            println "Enter new maximum image sheet size, ex: 4096 or 4096x4096:"
            print( cmd + " ...> " ).flush
            AssetManager.set_max_image_sheet_size( Console.read_line )
          endIf
          return null

        case "group"  # Change Group
          if (not AssetManager.cur_platform_name)
            println "Create a platform first (e.g. 'platform iOS')."
            return null
          endIf

          configure_options( AssetManager.cur_group_name, AssetManager.group_names, args, "group", "new group name" )
          if (args)
            AssetManager.save_undo( "$ $"(cmd,args) )
            if (user_choices.count)
              println "> Change Group " + user_choices.first
              AssetManager.change_group( user_choices.first )
            endIf
            AssetManager.change_to_available_platform
            return null
          elseIf (display_options("Change Group"))
            return cmd
          else
            println "No groups exist."
            return null
          endIf

        case "rmgroup"  # Remove Group
          configure_options( AssetManager.cur_group_name, AssetManager.group_names, args, "group" )
          if (args)
            AssetManager.save_undo( "$ $"(cmd,args) )
            forEach (group in user_choices)
              println "> Remove Group " + group
              AssetManager.delete_group( group )
            endForEach
            AssetManager.change_to_available_group
            return null
          elseIf (display_options("Remove Group"))
            return cmd
          else
            println "No groups exist."
            return null
          endIf


        case "undo"
          if (AssetManager.undo_stack.count)
            local state = AssetManager.undo_stack.remove_last
            println "Undo " + state.cmd
            AssetManager.redo_stack.add( state.cmd )
            AssetManager.load_inventory( ValueTable.parse(state.inventory) )
            AssetManager.load_config( ValueTable.parse(state.config) )
          else
            println "No commands to undo."
          endIf
          return null

        case "view"
          if (not AssetManager.cur_group_name)
            println "ERROR: No asset groups exist."
            return null
          endIf

          if (not AssetManager.cur_group//assets.count)
            println "ERROR: No assets have been added to the current group."
            return null
          endIf

          System.run( ''open -R "$"; osascript -e 'tell app "Finder" to set current view of Finder window 1 to flow view' ''...
            (AssetManager.cur_group//assets.first//filepath) )

          return null

        others
          println "Unknown command: " + cmd
          return null
      endWhich

    method get_listing( pattern=null:String, &folders, &recursive, &absolute )->String[]
      local omit_path = not absolute
      local listing : String[]
      if (recursive)
        listing = File.listing( AssetManager.cur_folder, &recursive, &absolute=absolute, &ignore_hidden, &omit_path=omit_path )
      else
        listing = File.listing( AssetManager.cur_folder, &absolute=absolute, &ignore_hidden, &omit_path=omit_path )
      endIf

      forEach (filepath in rewriter=listing.rewriter)
        if (pattern and not filepath.matches_wildcard_pattern(pattern)) nextIteration

        if (folders)
          if (File.is_folder("$/$" (AssetManager.cur_folder,filepath))) rewriter.write( filepath )
        elseIf (not File.is_folder("$/$" (AssetManager.cur_folder,filepath)))
          rewriter.write( filepath )
        endIf
      endForEach

      return listing

    method configure_options( current_option, options:String[], args:String, item_name=null:String, new_input_description=null )
      if (command_options is not options)
        command_options.clear
        if (options) command_options.add( options )
      endIf
      parse_args( args, item_name )

    method display_options( action_name:String, &showing_files )->Logical
      print "> "
      println action_name

      local w = Math.log10( command_options.count+1 ).ceiling->Int32
      local has_any = false
      if (current_option) has_any = true; println "$ $" (".".right_justified(w),current_option)
      forEach (option at index in command_options)
        has_any = true
        print "$ " ((index+1).right_justified(w))
        if (showing_files) AssetManager.print_filepath( option )
        else               print option
        println
      endForEach

      if (new_input_description)
        if (has_any) print "Or enter "
        else         print "Enter "
        println new_input_description
      endIf

      return (current_option? or command_options.count? or new_input_description?)

    method parse_args( args:String, item_name:String )
      local original_args = args

      user_choices.clear
      if (not args or not args.count) return

      if (command_options.count == 0 and not new_input_description) return

      if (args == ".")
        if (current_option) user_choices.add( current_option )
        return
      endIf

      if (command_options.contains(args))
        user_choices.add( args )
        return
      endIf

      if (args.contains('*') or args.contains('?'))
        forEach (option in command_options)
          if (option.matches_wildcard_pattern(args))
            user_choices.add( option )
          endIf
        endForEach
        return
      endIf

      if (not args[0].is_number and new_input_description)
        user_choices.add( args )
        return
      endIf

      args = args.replacing( ',', ' ' ).replacing( "..", "-" )
      forEach (arg in args.split(' '))
        if (arg.count == 0) nextIteration
        if (not arg[0].is_number) nextIteration
        if (arg.contains('-'))
          local range = arg.split('-')
          local first = range.first->Int32
          local last = select{ range.last.count:range.last->Int32 || command_options.count-1 }
          forEach (i in first..last)
            if (i >= 1 and i <= command_options.count)
              user_choices.add( command_options[i-1] )
            endIf
          endForEach
        else
          local i = arg->Int32
          if (i >= 1 and i <= command_options.count)
            user_choices.add( command_options[i-1] )
          endIf
        endIf
      endForEach

      if (user_choices.is_empty and item_name)
        println 'No $ found matching "$".' (item_name,original_args)
      endIf

endClass

class ConfigureDisplayTargets
  METHODS
    method execute->this
      println "$ Display Targets" (AssetManager.cur_platform_name)
      local has_any = false
      forEach (target at i in AssetManager.cur_platform//display_targets)
        println "$ $" (i,target//description)
        has_any = true
      endForEach
      if (not has_any) println "  (None)"

      println "-" * 79
      println @|Each display target causes a unique set of images to be generated.
      println "COMMANDS"
      println "add <name> <true size> [<nominal size>]"
      println "  Examples: add iPadRetina 1536x2048"
      println "            add iPadPro    2048x2732 1536x2048"
      println "rm  <name>"
      print( ">>> " ).flush

      local input = Console.read_line
      if (input.contains('\e'))
        # cancel anything with escape characters from arrow keys
        return this
      endIf

      input = input.trimmed
      if (input.count == 0) return null

      if (input == "q") return null

      #local args = input.after_first( ' ' )
      input = input.before_first( ' ' )

      if ("add".begins_with(input))
        trace "TODO"
        return this

      elseIf ("remove".begins_with(input))
        trace "TODO"
        return this

      else
        println "ERROR: Invalid command " + input
      endIf

      return this

    method parse_character_map( args:String )->ValueList
      try
        local map = @[]
        args = args.trimmed
        if (args.count)
          local reader = ParseReader( args )
          while (reader.has_another)
            local value = JSON.parse_value( reader )
            if (not value)
              println "Syntax error in arguments."
              return null
            endIf
            reader.consume_spaces
            if (reader.consume('-'))
              # low-high
              local low = select{ value.is_string:value->String[0] || value->Int32 }
              value = JSON.parse_value( reader )
              local high = select{ value.is_string:value->String[0] || value->Int32 }
              map.add( forEach in low..high )
            else
              # single
              if (value.is_string) map.add( forEach in value->String )
              else                 map.add( value->Int32 )
            endIf
            reader.consume_spaces
          endWhile
        else
          map.add( forEach in 32..126 )
        endIf

        return map

      catch (Error)
        println "Syntax error in arguments."
        return null
      endTry
endClass

class ExamineImageAsset
  PROPERTIES
    index      : Int32
    asset_name : String
    short_name : String
    asset      : Value

  METHODS
    method init( index, asset_name )
      short_name = AssetManager.short_asset_name( asset_name )
      asset = AssetManager.cur_group//assets[ asset_name ]

    method examine->ExamineImageAsset
      if (not File.exists(asset_name))
        println "ERROR: File not found."
        return null
      endIf

      local bitmap = AssetManager.get_bitmap( asset_name )
      if (not bitmap)
        println "ERROR: Unable to load image \"$\"." (asset_name)
        return null
      endIf

      println "-" * 79
      print '['
      print index+1
      print "] "
      println short_name

      println"$x$ Image" (bitmap.width,bitmap.height)
      if (asset//operations.count)
        print "Operations: ["
        local first = true
        forEach (op in asset//operations)
          if (first) first = false
          else       print ','
          print op//label
        endForEach
        println ']'
      endIf
      println "-" * 79
      println "COMMANDS"
      println "clear (clear operations)"
      println ''varfont ["character map" | 'character' | unicode | <low>-<high> ...]*''
      println "  Default mapping equivalent to: varfont 32-126 AKA varfont ' '-'~'"
      println "split <tiles-wide>x<tiles-high>"
      println "resample <width>x<height> (resizes pixel data while retaining display size)"
      println "rescale  [<scale>|<top>/<bottom>] (resizes both pixel data and display size)"
      println "view"
      println "(p)revious, (n)ext"
      #{
      print AssetManager.cur_platform_name
      print "::"
      print AssetManager.cur_group_name
      print "::"
      }#
      print( ">>> " ).flush

      local input = Console.read_line
      if (input.contains('\e'))
        # cancel anything with escape characters from arrow keys
        return this
      endIf

      input = input.trimmed
      if (input.count == 0) return null

      if (input == "q") return null

      local args = input.after_first( ' ' )
      input = input.before_first( ' ' )

      if (input == "p")
        index = (index - 1) % AssetManager.cur_group//assets.count
        return ExamineImageAsset( index, AssetManager.cur_group//assets[index]//filepath )

      elseIf (input == "n")
        index = (index + 1) % AssetManager.cur_group//assets.count
        return ExamineImageAsset( index, AssetManager.cur_group//assets[index]//filepath )

      elseIf ("view".begins_with(input) and input.count >= 2)
        System.run( ''open -R "$"; osascript -e 'tell app "Finder" to set current view of Finder window 1 to flow view' ''...
          (asset_name) )
        return this

      elseIf ("clear".begins_with(input))
        asset//operations = @[]
        AssetManager.mark_group_modified
        return this

      elseIf ("split".begins_with(input))
        if (not args.contains('x'))
          println ''<tiles-wide>x<tiles-high> argument expected.  Ex: "split 13x4".''
          return this
        endIf
        local dims = args.split( 'x' )
        local w = dims.first->Int32
        local h = dims.last->Int32
        asset.ensure_list( "operations" ).add( @{name:"split",tiles_wide:w,tiles_high:h,label:"split $x$"(w,h)} )
        AssetManager.mark_group_modified
        return this

      elseIf ("varfont".begins_with(input) and input.count >= 2)
        if (asset//operations.first( //name == "varfont" ))
          println "ERROR: Asset is already marked as a font."
          return this
        endIf

        local map = parse_character_map( args )
        if (not map) return this

        asset.ensure_list( "operations" ).add( @{name:"varfont",characters:map,label:"varfont "+args} )
        AssetManager.mark_group_modified

        return this

      elseIf ("resample".begins_with(input) and input.count >= 4)
        if (not args.contains('x'))
          println ''<width>x<height> argument expected.  Ex: "resample 320x200".''
          return this
        endIf
        local dims = args.split( 'x' )
        local w = dims.first->Int32
        local h = dims.last->Int32
        asset.ensure_list( "operations" ).add( @{name:"resample",width:w,height:h,label:"resample $x$"(w,h)} )
        AssetManager.mark_group_modified
        return this

      elseIf ("rescale".begins_with(input) and input.count >= 4)
        local s = scale_string_to_value( args )
        asset.ensure_list( "operations" ).add( @{name:"rescale",scale:s,label:"rescale $"(args)} )
        AssetManager.mark_group_modified
        return this

      endIf

      println "ERROR: Invalid command " + input
      return this

    method parse_character_map( args:String )->ValueList
      try
        local map = @[]
        args = args.trimmed
        if (args.count)
          local reader = ParseReader( args )
          while (reader.has_another)
            local value = JSON.parse_value( reader )
            if (not value)
              println "Syntax error in arguments."
              return null
            endIf
            reader.consume_spaces
            if (reader.consume('-'))
              # low-high
              local low = select{ value.is_string:value->String[0] || value->Int32 }
              value = JSON.parse_value( reader )
              local high = select{ value.is_string:value->String[0] || value->Int32 }
              map.add( forEach in low..high )
            else
              # single
              if (value.is_string) map.add( forEach in value->String )
              else                 map.add( value->Int32 )
            endIf
            reader.consume_spaces
          endWhile
        else
          map.add( forEach in 32..126 )
        endIf

        return map

      catch (Error)
        println "Syntax error in arguments."
        return null
      endTry
endClass

class Placement
  PROPERTIES
    asset  : Value
    bitmap : Bitmap
    display_width  : Real64
    display_height : Real64

    # top-left corner on image sheet
    sx          : Int32
    sy          : Int32

    # Piece index
    index       : Int32
    settings    = UndefinedValue : Value

    image_sheet : ImageSheet

  METHODS
    method init( asset )
      bitmap = AssetManager.get_bitmap( asset//filepath )
      if (bitmap)
        display_width =  bitmap.width
        display_height = bitmap.height
        asset//cache = @{ piece_count:0, type:"TextureImage", display_size:{width:display_width,height:display_height} }
      else
        println "ERROR: Unable to load image."
      endIf

    method init( asset, bitmap, display_width, display_height, settings=null )

    method collect( placements:Placement[] )
      collect( asset//operations, placements )

    method collect( operations:Value, placements:Placement[] )
      if (operations and operations.count)
        local op = operations.first
        which (op//name)
          case "split"
            asset//cache//type = "Image[]"
            local tiles_wide = op//tiles_wide->Int32
            local tiles_high = op//tiles_high->Int32
            local tpw = bitmap.width   / tiles_wide  # Tile Pixel Width/Height
            local tph = bitmap.height  / tiles_high
            local tdw = display_width  / tiles_wide  # Tile Display Width/Height
            local tdh = display_height / tiles_high
            forEach (j in 0..<tiles_high)
              forEach (i in 0..<tiles_wide)
                Placement( asset, Bitmap(bitmap,Box(i*tpw,j*tph,tpw,tph)), tdw, tdh ).collect( operations.rest, placements )
              endForEach
            endForEach

          case "varfont"
            asset//cache//type = "Font"

            local pixels = bitmap.pixels
            local bitmap_width = bitmap.width
            local h = bitmap.height - 1
            local characters = op//characters
            local x1 = 0
            forEach (ch at ch_index in characters)
              if (x1 >= bitmap_width)
                println "ERROR: font parameters for $ specify more characters ($) than exist in the font strip ($)." (asset//filepath,characters.count,ch_index)
                return
              endIf
              local argb = pixels[x1].argb
              local x2 = x1 + 1
              while (x2 < bitmap_width and pixels[x2].argb == argb) ++x2
              --x2
              local w = (x2 - x1) + 1
              local subset = Box( x1, 1, w, h )
              local settings = @{ unicode:ch }
              Placement( asset, Bitmap(bitmap,subset), w, h, settings ).collect( operations.rest, placements )
              x1 = x2 + 1
            endForEach

          case "resample"
            local w = op//width->Int32
            local h = op//height->Int32
            Placement( asset, bitmap.resized(w,h), display_width, display_height ).collect( operations.rest, placements )

          case "rescale"
            local s = op//scale->Real64
            local w = (bitmap.width * s)->Int32
            local h = (bitmap.height * s)->Int32
            Placement( asset, bitmap.resized(w,h), (display_width*s)->Int32, (display_height*s)->Int32 ).collect( operations.rest, placements )

          others
            println "ERROR processing $: Unsupported operation $." (asset//filepath,op//label)
        endWhich
      else
        index = asset//cache//piece_count
        asset//cache//piece_count += 1
        placements.add( this )
      endIf

    method display_size->Value
      return @{ width:display_width, height:display_height }

    method info->Value
      return @{ filename:image_sheet.filename,
          bounds:{ x:sx, y:sy, width:bitmap.width, height:bitmap.height }
        }

    method render( to_bitmap:Bitmap )
      local pos = XY(sx,sy)
      local size = XY( bitmap.width, bitmap.height )

      bitmap.blit( to_bitmap, XY(sx,sy) )

      # Extend each edge 1 pixel to prevent rendering artifacts
      to_bitmap.blit( Box(pos,size.x,1),                to_bitmap, pos - XY(0,1) )  # top
      to_bitmap.blit( Box(pos+XY(0,size.y-1),size.x,1), to_bitmap, pos + size.yv )  # bottom

      to_bitmap.blit( Box(pos-XY(0,1),1,size.y+2),         to_bitmap, pos-XY(1,1) )         # left
      to_bitmap.blit( Box(pos+size.xv-XY(1,1),1,size.y+2), to_bitmap, pos+size.xv-XY(0,1) ) # right

    method to->String
      #return "$ $x$ @($,$)" (asset//filepath,bitmap.width,bitmap.height,sx,sy)
      return "$ #$" (File.filename(asset//filepath),index)

endClass

class ImageSheet
  PROPERTIES
    placements = Placement[]
    width      : Int32
    height     : Int32
    filename   : String

  METHODS
    method init( width, height )

    method render_and_save( folder:String, filename, &view_result )
      local filepath = folder + filename
      println "  Writing $ [$x$]" (filepath,width,height)

      local sheet = Bitmap( width, height, Color.BLUE )
      forEach (placement in placements)
        placement.image_sheet = this
        placement.render( sheet )
      endForEach

      File.save( filepath, sheet.to_png_bytes )
      if (view_result) System.run( ''open -a Preview "$"'' (filepath) )

endClass

class ImageCompiler
  PROPERTIES
    output_folder    : String
    base_output_name : String

  METHODS
    method compile( &view_result )->Logical
      output_folder = "$Assets/Images/" (AssetManager.cur_build_folder)
      base_output_name = ("$-$-" (AssetManager.cur_platform_name,AssetManager.cur_group_name)).replacing('/','-').replacing('\\','-')

      if (File.exists(output_folder))
        if (not File.is_folder(output_folder))
          throw Error( "ERROR: Cannot create output folder $ because a file by that name already exists." (output_folder) )
        endIf
      else
        File.create_folder( output_folder )
      endIf

      if (not needs_compile) return false

      # Delete any existing files
      local filter = base_output_name + "*"
      forEach (filepath in File.listing(output_folder,&ignore_hidden,&omit_path))
        if (filepath.matches_wildcard_pattern(filter))
          File.delete( output_folder + filepath )
        endIf
      endForEach

      local sheets = perform_layout
      if (not sheets) return true  # even with error, still return true for "needed compile"

      # Render each image sheet
      forEach (sheet at index in sheets)
        sheet.render_and_save( output_folder, "$$.png" (base_output_name,index.right_justified(2,'0')), view_result )
      endForEach

      return generate_manifest( sheets )

    method perform_layout->ImageSheet[]
      # collect asset placements
      local placements = collect_placements
      if (not placements) return null

      if (not placements.count)
        println "ERROR: Group [$::$] does not contain any assets to compile." (AssetManager.cur_platform_name,AssetManager.cur_group_name)
        return null
      endIf

      local max_w = select{ AssetManager.cur_group//max_image_sheet_width->Int32  || 2048 }
      local max_h = select{ AssetManager.cur_group//max_image_sheet_height->Int32 || 2048 }
      max_w = max_w.to_power_of_two
      max_h = max_h.to_power_of_two

      local sheets = ImageSheet[]
      while (placements.count)
        local info = perform_layout( placements, max_w, max_h )
        if (not info)
          local w = placements.first.bitmap.width->Int32
          local h = placements.first.bitmap.height->Int32
          local min_size = w.to_power_of_two.or_larger( h.to_power_of_two )
          println "ERROR: $ ($x$) is too large to fit on a $x$ image sheet.  Use the (s)heetsize command " ...
                  "to increase the group's maximum image sheet size to $x$ or greater." ...
                  (placements.first.asset//filepath,w,h,max_w,max_h,min_size,min_size)
          return null
        endIf
        sheets.add( info )
      endWhile

      require sheets.count

      # Try reducing the size of the last sheet by redoing the layout
      local last_sheet = sheets.remove_last

      loop
        placements.clear.add( last_sheet.placements )
        local better_fit = perform_layout( placements, last_sheet.width, last_sheet.height/2 )
        if (better_fit and placements.count == 0)
          last_sheet = better_fit
          nextIteration
        endIf

        placements.clear.add( last_sheet.placements )
        better_fit = perform_layout( placements, last_sheet.width/2, last_sheet.height )
        if (better_fit and placements.count == 0)
          last_sheet = better_fit
          nextIteration
        endIf

        escapeLoop
      endLoop

      # Redo the last sheet layout one final time with the best dimensions - any failed
      # attempts above have left the images positioned badly.
      placements.clear.add( last_sheet.placements )
      last_sheet = perform_layout( placements, last_sheet.width, last_sheet.height )

      sheets.add( last_sheet )

      AssetManager.cur_group//image_sheet_count = sheets.count
      return sheets

    method needs_compile->Logical
      local cur_group = AssetManager.cur_group

      if (not cur_group.contains("cache"))             return true
      if (not cur_group//cache.contains("manifest"))   return true
      if (not cur_group.contains("image_sheet_count")) return true
      if (not cur_group.contains("timestamp"))         return true

      if (not File.exists(output_folder)) return true

      local timestamp = cur_group//timestamp->Real64

      # See if time of last Inventory.json modification is newer than any
      # output image sheets.
      local matching_file_count = 0
      local filter = base_output_name + "*"
      local oldest_output_timestamp : Real64?
      forEach (filepath in File.listing(output_folder,&ignore_hidden,&omit_path))
        if (filepath.matches_wildcard_pattern(filter))
          ++matching_file_count
          local output_timestamp = File.timestamp( output_folder + filepath )
          if (output_timestamp < timestamp) return true
          if (not oldest_output_timestamp.exists or output_timestamp < oldest_output_timestamp.value)
            oldest_output_timestamp = output_timestamp
          endIf
        endIf
      endForEach

      # See if any original asset image has a timestamp greater than any output image
      if (File.timestamp( (forEach in cur_group//assets)//filepath->String ) > oldest_output_timestamp.value)
        return true
      endIf

      return (cur_group//image_sheet_count != matching_file_count)

    method collect_placements->Placement[]
      local placements = Placement[]
      forEach (asset in AssetManager.cur_group//assets)
        local placement = Placement( asset )
        if (not placement.bitmap) return null
        placement.collect( placements )
      endForEach

      return placements


    method perform_layout( placements:Placement[], max_width:Int32, max_height:Int32 )->ImageSheet
      InsertionSort<<Placement>>.sort( placements,
        function(a:Placement,b:Placement)->(Logical)
          # 'a' should come before 'b' when:
          if (a.bitmap.height > b.bitmap.height) return true
          if (a.bitmap.height < b.bitmap.height) return false
          # Heights are equal

          return (a.bitmap.width > b.bitmap.width)
        endFunction
      )

      local sheet = ImageSheet( max_width, max_height )
      if (perform_layout(placements, -1, -1, max_width+2, max_height+2, sheet)) return sheet
      else return null

    method perform_layout( placements:Placement[], sx:Int32, sy:Int32, sw:Int32, sh:Int32, image_sheet:ImageSheet )->Logical
      # Find the largest asset we can place (including a 1-pixel border around
      # the edge), delete it from the list, and then recursively place any
      # remaining placements we can.
      forEach (placement in placements)
        local w = (placement.bitmap.width  + 2)->Int32
        local h = (placement.bitmap.height + 2)->Int32
        if (w <= sw and h <= sh)
          placement.sx = sx+1
          placement.sy = sy+1
          placements.remove( placement )
          image_sheet.placements.add( placement )

          # We've just placed 'A', now recursively fill areas 'B' and 'C':
          #
          # AAA|BBBBBB
          # AAA|BBBBBB
          # ---+------
          # CCCCCCCCCC
          # CCCCCCCCCC
          # CCCCCCCCCC
          perform_layout( placements, sx+w, sy,   sw-w, h,    image_sheet )   # B
          perform_layout( placements, sx,   sy+h, sw,   sh-h, image_sheet )   # C

          return true
        endIf
      endForEach

      # Unable to place any
      return false

    method generate_manifest( sheets:ImageSheet[] )->Logical
      local image_placements = Table<<String,Placement[]>>()
      forEach (sheet in sheets)
        forEach (placement in sheet.placements)
          local asset_name = placement.asset//filepath
          ensure image_placements[ asset_name ]
          image_placements[ asset_name ].expand_to_include( placement.index )
          image_placements[ asset_name ][ placement.index ] = placement
        endForEach
      endForEach

      local group = AssetManager.cur_group
      local group_name = group//name->String
      local manifest = @{ name:group_name }
      local textures = @[]
      local images = @[]
      manifest//textures = textures
      manifest//images = images

      forEach (sheet in sheets)
        textures.add( @{ filename:sheet.filename, size:{width:sheet.width,height:sheet.height} } )
      endForEach

      forEach (asset in group//assets)
        local placements = image_placements[ asset//filepath ]
        require placements

        local img_name = shorten( asset//filepath->String )
        local path = File.path( img_name )
        local common_count = img_name.leftmost_common_substring_count( path )
        img_name = group_name + select{ common_count:img_name.rightmost( -common_count ) || "/" + img_name }
        local img = @{ type:asset//cache//type, name:img_name, display_size:asset//cache//display_size }
        images.add( img )
        which (img//type)
          case "Image[]"
            img//images = @[]
            forEach (placement in placements)
              local piece = @{ type:"TextureImage", display_size:placement.display_size }
              piece//texture = placement.info
              img//images.add( piece )
            endForEach

          case "Font"
            img//characters = @[]
            forEach (placement in placements)
              local ch = @{ type:"TextureImage", display_size:placement.display_size, unicode:placement.settings//unicode }
              ch//texture = placement.info
              img//characters.add( ch )
            endForEach

          case "TextureImage"
            require (placements.count == 1)
            img//texture = placements.first.info

          others
            println "INTERNAL ERROR: Unsupported image type in generate_manifest(): $." (img//type)
            return false
        endWhich

      endForEach

      group.ensure_table( "cache" )//manifest = manifest

      return true

    method shorten( asset_name:String )->String
      if (not asset_name.to_lowercase.begins_with("assets/images/")) return asset_name
      return asset_name.rightmost( -("Assets/Images/".count) )

endClass
