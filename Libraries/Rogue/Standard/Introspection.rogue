class Introspector
  GLOBAL METHODS
    method _ret_Object (p:IntPtr)->Value
      return native("*(RogueObject**)$p")->Object
    method _ret_Real64 (p:IntPtr)->Value
      return native("*(RogueReal64*)$p")->Real64
    method _ret_Real32 (p:IntPtr)->Value
      return native("*(RogueReal32*)$p")->Real32
    method _ret_Int64 (p:IntPtr)->Value
      return native("*(RogueInt64*)$p")->Int64
    method _ret_Int32 (p:IntPtr)->Value
      return native("*(RogueInt32*)$p")->Int32
    method _ret_Character (p:IntPtr)->Value
      return native("*(RogueCharacter*)$p")->Character
    method _ret_Byte (p:IntPtr)->Value
      return native("*(RogueByte*)$p")->Byte
    method _ret_String (p:IntPtr)->Value
      return native("*(RogueString**)$p")->String
    method _ret_Logical (p:IntPtr)->Value
      return native("*(RogueLogical*)$p")->Logical
    method _ret_undefined (p:IntPtr)->Value
      return UndefinedValue

    method _call( fn:IntPtr, i:Int32, args:Value )->Value
      # fn: function pointer
      # i:  IntrospectionCallHandler index
      # Send a @[list] as the value args.

      # Note: compiler relies on parameters having specific names (fn,i,args)
      # Compiler will insert generated code here
      return UndefinedValue

  PROPERTIES
    context : Object
    address : IntPtr
    info    : TypeInfo

  METHODS
    method init( context )
      address = native( "((intptr_t)$context)" )->IntPtr
      info = context.type_info

    method init( context, address, info )

    method get( name:String )->Value
      local property_info = info.property_info( name )
      if (not property_info) return NullValue

      if (property_info.type.is_reference)
        return Value( native( "*((RogueObject**)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Object )
      endIf

      which (property_info.type.name)
        case "Real64"
          return Value( native( "*((RogueReal64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Real64 )

        case "Real32"
          return Value( native( "*((RogueReal32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Real32 )

        case "Int64"
          return Value( native( "*((RogueInt64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Int64 )

        case "Int32"
          return Value( native( "*((RogueInt32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Int32 )

        case "Character"
          return Value( native( "*((RogueCharacter*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Character + "" )

        case "Byte"
          return Value( native( "*((RogueByte*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Byte )

        case "Logical"
          return Value( native( "*((RogueLogical*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index]))" )->Logical )

        others
          # Must be a compound
          return Introspector( context, native( "(RogueInt64)(intptr_t)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])" )->Int64, property_info.type )->Value
      endWhich

    method set( name:String, new_value:Value )->this
      local property_info = info.property_info( name )
      if (not property_info) return this

      if (property_info.type.is_reference)
        local value = new_value->Object
        native( "*((RogueObject**)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )
        return this
      endIf

      which (property_info.type.name)
        case "Real64"
          local value = new_value->Real64
          native( "*((RogueReal64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Real32"
          local value = new_value->Real32
          native( "*((RogueReal32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Int64"
          local value = new_value->Int64
          native( "*((RogueInt64*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Int32"
          local value = new_value->Int32
          native( "*((RogueInt32*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Character"
          local value = new_value->Character
          native( "*((RogueCharacter*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Byte"
          local value = new_value->Byte
          native( "*((RogueByte*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        case "Logical"
          local value = new_value->Logical
          native( "*((RogueLogical*)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])) = $value;" )

        others
          # Must be a compound
          Introspector( context, native( "(RogueInt64)(intptr_t)(((RogueByte*)(intptr_t)$address) + Rogue_types[$info->index].property_offsets[$property_info->index])" )->Int64, property_info.type ).set( new_value )
      endWhich

      return this

    method set( new_value:Value )->this
      if (new_value.is_table)
        forEach (key in (new_value as ValueTable).keys)
          set( key, new_value[key] )
        endForEach
        return this
      endIf

      if (info.is_reference)
        native( "*(RogueObject**)((RogueByte*)(intptr_t)$address)" )->Object = new_value->Object
        return this
      endIf

      which (info.name)
        case "Real64"
          native( "*(RogueReal64*)((RogueByte*)(intptr_t)$address)" )->Real64 = new_value->Real64

        case "Real32"
          native( "*(RogueReal32*)((RogueByte*)(intptr_t)$address)" )->Real32 = new_value->Real32

        case "Int64"
          native( "*(RogueInt64*)((RogueByte*)(intptr_t)$address)" )->Int64 = new_value->Int64

        case "Int32"
          native( "*(RogueInt32*)((RogueByte*)(intptr_t)$address)" )->Int32 = new_value->Int32

        case "Character"
          native( "*(RogueCharacter*)((RogueByte*)(intptr_t)$address)" )->Character = new_value->Character

        case "Byte"
          native( "*(RogueByte*)((RogueByte*)(intptr_t)$address)" )->Byte = new_value->Byte

        case "Logical"
          native( "*(RogueLogical*)((RogueByte*)(intptr_t)$address)" )->Logical = new_value->Logical

      endWhich

      return this

    method to->String
      return this->Value->String

    method to->Value
      local result = @{}
      forEach (p in info.properties)
        result[ p.name ] = this[ p.name ]
      endForEach
      return result

    method call ( name:String, args:ValueList )->Value
      return call(name, args.data)

    method call ( name:String, args:Value[] )->Value
      local methods = context.type_info.method_info( name )
      #TODO: We can do better method selection than this, but for now, we go simple:
      #      pick the first one with the matching number of parameters.  If we end
      #      up not being able to convert an argument, we try the next one.
      #local msgs = String[]
      forEach (m in methods)
        if (m.param_count == args.count)
          try
            return call(m, args)
          catch (ex : NoMatchingMethodError)
            noAction # Try the next one
            #msgs.add(ex.message)
          endTry
        endIf
      endForEach
      #println msgs
      throw Error("No matching method '$' ($ candidate(s))" (name, methods.count))

$if (NO_LIBFFI)
    # This allows for the use of dynamic function invocation without libffi.
    # It currently only supports the System V AMD64 ABI.
    # This code is pretty awful and you're better off using libffi!

    #TODO: Integrate this with the FFI code (there's a lot of commonality).

    nativeCode
      extern "C" void rogue_call_func (void * fn_ptr, /*ROGUE_ARG_TYPE ret_type,*/ void * ret_buf, /*ROGUE_ARG_TYPE*/ int * types, int64_t * cargs, int64_t * fargs);
      __asm__(
        ".text \n"
        ".align 0 \n"
#ifdef __APPLE__
        ".globl _rogue_call_func \n"
        "_rogue_call_func :\n"
#else
        ".globl rogue_call_func \n"
        "rogue_call_func :\n"
#endif

        "pushq %r10 \n" // Push an extra to align the stack

        "pushq %r10 \n"
        "pushq %r11 \n"

        "pushq %rdi \n"
        "pushq %rsi \n"
        "pushq %rdx \n"
        "pushq %rcx \n"
        "pushq %r8 \n"
        "pushq %r9 \n"

        "movq %xmm0, %r10 \n"
        "pushq %r10 \n"
        "movq %xmm1, %r10 \n"
        "pushq %r10 \n"
        "movq %xmm2, %r10 \n"
        "pushq %r10 \n"
        "movq %xmm3, %r10 \n"
        "pushq %r10 \n"
        "movq %xmm4, %r10 \n"
        "pushq %r10 \n"
        "movq %xmm5, %r10 \n"
        "pushq %r10 \n"
        "movq %xmm6, %r10 \n"
        "pushq %r10 \n"
        "movq %xmm7, %r10 \n"
        "pushq %r10 \n"

        "movq %rdi, %r11 \n"

        "movq %r8, %r10 \n" // fargs
        "movq 0(%r10), %xmm0 \n"
        "movq 8(%r10), %xmm1 \n"
        "movq 16(%r10), %xmm2 \n"
        "movq 24(%r10), %xmm3 \n"
        "movq 32(%r10), %xmm4 \n"
        "movq 40(%r10), %xmm5 \n"
        "movq 48(%r10), %xmm6 \n"
        "movq 56(%r10), %xmm7 \n"

        "movq %rcx, %r10 \n" // cargs
        "movq 0(%r10), %rdi \n"
        "movq 8(%r10), %rsi \n"
        "movq 16(%r10), %rdx \n"
        "movq 24(%r10), %rcx \n"
        "movq 32(%r10), %r8 \n"
        "movq 40(%r10), %r9 \n"

        "call *%r11 \n"

        "movq %xmm0, %r11 \n"

        "popq %r10 \n"
        "movq %r10, %xmm7 \n"
        "popq %r10 \n"
        "movq %r10, %xmm6 \n"
        "popq %r10 \n"
        "movq %r10, %xmm5 \n"
        "popq %r10 \n"
        "movq %r10, %xmm4 \n"
        "popq %r10 \n"
        "movq %r10, %xmm3 \n"
        "popq %r10 \n"
        "movq %r10, %xmm2 \n"
        "popq %r10 \n"
        "movq %r10, %xmm1 \n"
        "popq %r10 \n"
        "movq %r10, %xmm0 \n"

        "popq %r9 \n"
        "popq %r8 \n"
        "popq %rcx \n"
        "popq %rdx \n"
        "popq %rsi \n"
        "popq %rdi \n"

        "movq %rax, 0( %rsi ) \n" // ret_buf
        "movq %r11, 8( %rsi ) \n" // ret_buf

        "popq %r11 \n"
        "popq %r10 \n"

        "popq %r10 \n"

        "ret \n"
        ".previous \n"
      );
    endNativeCode

    method call ( m:MethodInfo, args:Value[] )->Value
      require args.count < 8+6 || "Too many arguments for dynamic invocation without libffi"

      assert m.param_count == args.count
      local r_buf_ptr : IntPtr
      native @|#define ROGUE_ARG_PTR 0
              |#define ROGUE_ARG_INT8 0
              |#define ROGUE_ARG_INT32 0
              |#define ROGUE_ARG_INT64 0
              |#define ROGUE_ARG_FLOAT32 1
              |#define ROGUE_ARG_FLOAT64 2
              |#define ROGUE_ARG_VOID 3
              |
              |#define ROGUE_ARG_TYPE int
              |int types[8+6];
              |int * next_type = types;
              |int64_t fargs[8+6]; // Allocate too much space because we don't check the counts
              |int64_t cargs[8+6]; // until later
              |int64_t * next_farg = fargs;
              |int64_t * next_carg = cargs;
              |#define ROGUE_ARG_PUSH(_t,_f,_v) { \
              |  if ((_f) == ROGUE_ARG_FLOAT32 || (_f) == ROGUE_ARG_FLOAT64) *(next_farg++) = *(int64_t*)(&(_v)); \
              |  else *(next_carg++) = *(int64_t*)(&(_v)); \
              |  *(next_type++) = _f; \
              |}
              |char r_buf[16]; // Return buffer, must be large enough for largest type
              |$r_buf_ptr = (intptr_t)(void *)r_buf;

      native "ROGUE_ARG_PUSH(RogueObject*, ROGUE_ARG_PTR, $this->context);"

      forEach (p at index in m.param_types)
        local a = args[index]
        which (p.name)
          case "String"
            _check_param(index, p, a.is_string)
            block
              local c = a->String
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_PTR, $c);"
            endBlock
            nextIteration

          case "Real64"
            _check_param(index, p, a.is_number)
            block
              local c = a->Real64
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_FLOAT64, $c);"
            endBlock
            nextIteration
          case "Real32"
            _check_param(index, p, a.is_number)
            block
              local c = a->Real32
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_FLOAT32, $c);"
            endBlock
            nextIteration
          case "Int64"
            #_check_param(index, p, a.is_int64 or a.is_int32)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Int64
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_INT64, $c);"
            endBlock
            nextIteration
          case "Int32"
            #_check_param(index, p, a.is_int32)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Int32
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_INT32, $c);"
            endBlock
            nextIteration
          case "Character"
            #_check_param(index, p, a.is_character)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Character
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_INT32, $c);"
            endBlock
            nextIteration
          case "Byte"
            #_check_param(index, p, a.is_byte)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Byte
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_INT8, $c);"
            endBlock
            nextIteration
          case "Logical"
            _check_param(index, p, a.is_logical)
            block
              local c = a->Logical->Int64
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_INT64, $c);"
            endBlock
            nextIteration
          others
            if (p.is_reference)
              _check_param(index, p, a.is_object)
              local c = a->Object
              native "ROGUE_ARG_PUSH($(c.type), ROGUE_ARG_PTR, $c);"
              nextIteration
            endIf
        endWhich

        throw NoMatchingMethodError("Argument $ is of unhandled type $" (index+1, p.name))
      endForEach

      require(native("next_carg-cargs")->Int32 <= 6 || "Too many non-floating-point arguments for dynamic invocation without libffi")
      require(native("next_farg-fargs")->Int32 <= 8 || "Too many floating-point arguments for dynamic invocation without libffi")

      native "ROGUE_ARG_TYPE ret_type = ROGUE_ARG_VOID;"

      local rt = m.return_type
      local ret_func = this=>_ret_undefined : (Function(IntPtr)->Value)
      block
        if (rt is null)
          escapeBlock
        endIf

        which (rt.name)
          case "Real64"
            native "ret_type = ROGUE_ARG_FLOAT64;"
            ret_func = this=>_ret_Real64
          case "Real32"
            native "ret_type = ROGUE_ARG_FLOAT32;"
            ret_func = this=>_ret_Real32
          case "Int64"
            native "ret_type = ROGUE_ARG_INT64;"
            ret_func = this=>_ret_Int64
          case "Int32"
            native "ret_type = ROGUE_ARG_INT32;"
            ret_func = this=>_ret_Int32
          case "Character"
            native "ret_type = ROGUE_ARG_INT32;"
            ret_func = this=>_ret_Character
          case "Byte"
            native "ret_type = ROGUE_ARG_INT8;"
            ret_func = this=>_ret_Byte
          case "Logical"
            block
              native "ret_type = ROGUE_ARG_INT64;"
            endBlock
            ret_func = this=>_ret_Logical
          case "String"
            native "ret_type = ROGUE_ARG_PTR;"
            ret_func = this=>_ret_String
          others
            if (rt.is_reference)
              native "ret_type = ROGUE_ARG_PTR;"
              ret_func = this=>_ret_Object
              escapeBlock
            endIf
            throw NoMatchingMethodError("Return type is of unhandled type $" (rt.name))
        endWhich
      endBlock

      local fn_ptr = m.fn_ptr

      native "rogue_call_func((void*)$fn_ptr, r_buf, types, cargs, fargs);"

      if (native("ret_type")->Int32 == native("ROGUE_ARG_FLOAT32")->Int32 or native("ret_type")->Int32 == native("ROGUE_ARG_FLOAT64")->Int32)
        r_buf_ptr += 8
      endIf

      return ret_func(r_buf_ptr)

      native @|#undef ROGUE_ARG_PUSH
              |#undef ROGUE_ARG_PTR
              |#undef ROGUE_ARG_INT8
              |#undef ROGUE_ARG_INT32
              |#undef ROGUE_ARG_INT64
              |#undef ROGUE_ARG_FLOAT32
              |#undef ROGUE_ARG_FLOAT64
              |#undef ROGUE_ARG_VOID
              |#undef ROGUE_ARG_TYPE

$else
    method call ( m:MethodInfo, args:Value[] )->Value
      nativeHeader
        #include <ffi.h>
      endNativeHeader

      assert m.param_count == args.count
      local build = true
      local r_buf_ptr : IntPtr
      native @|ffi_cif cif;
              |ffi_type ** types = (ffi_type **)alloca(sizeof(ffi_type *) * ($args->count + 1));
              |ffi_type ** next_type = types;
              |void ** cargs = (void **)alloca(sizeof(void *) * ($args->count + 1));
              |void ** next_carg = cargs;
              |#define ROGUE_ARG_PUSH(_t,_f,_v) { \
              |  _t * tmp = (_t *) alloca( sizeof(_t) ); \
              |  *tmp = _v; \
              |  *(next_carg++) = tmp; \
              |  if ($build) *(next_type++) = &_f; \
              |}
              |char r_buf[16]; // Return buffer, must be large enough for largest type
              |$r_buf_ptr = (intptr_t)(void *)r_buf;

      native "ROGUE_ARG_PUSH(RogueObject*, ffi_type_pointer, $this->context);"

      forEach (p at index in m.param_types)
        local a = args[index]
        which (p.name)
          case "String"
            _check_param(index, p, a.is_string)
            block
              local c = a->String
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_pointer, $c);"
            endBlock
            nextIteration

          case "Real64"
            _check_param(index, p, a.is_number)
            block
              local c = a->Real64
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_double, $c);"
            endBlock
            nextIteration
          case "Real32"
            _check_param(index, p, a.is_number)
            block
              local c = a->Real32
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_float, $c);"
            endBlock
            nextIteration
          case "Int64"
            #_check_param(index, p, a.is_int64 or a.is_int32)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Int64
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_sint64, $c);"
            endBlock
            nextIteration
          case "Int32"
            #_check_param(index, p, a.is_int32)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Int32
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_sint32, $c);"
            endBlock
            nextIteration
          case "Character"
            #_check_param(index, p, a.is_character)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Character
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_sint32, $c);"
            endBlock
            nextIteration
          case "Byte"
            #_check_param(index, p, a.is_byte)
            _check_param(index, p, a.is_number and a->Real64.fractional_part==0)
            block
              local c = a->Byte
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_uint8, $c);"
            endBlock
            nextIteration
          case "Logical"
            _check_param(index, p, a.is_logical)
            block
              local c = a->Logical
              native @|static_assert(sizeof($c) == 4 || sizeof($c) == 8 || sizeof($c) == 1, "Logicals are of unhandled size on this platform");
                      |if (sizeof($c) == 4) {
                      |  int32_t cc = (int32_t)$c;
                      |  ROGUE_ARG_PUSH(int32_t, ffi_type_sint32, cc);
                      |} else if (sizeof($c) == 8) {
                      |  int64_t cc = (int64_t)$c;
                      |  ROGUE_ARG_PUSH(int64_t, ffi_type_sint32, cc);
                      |} else {
                      |  int8_t cc = (int8_t)$c;
                      |  ROGUE_ARG_PUSH(int8_t, ffi_type_sint8, cc);
                      |}
            endBlock
            nextIteration
          others
            if (p.is_reference)
              _check_param(index, p, a.is_object)
              local c = a->Object
              native "ROGUE_ARG_PUSH($(c.type), ffi_type_pointer, $c);"
              nextIteration
            endIf
        endWhich

        throw NoMatchingMethodError("Argument $ is of unhandled type $" (index+1, p.name))
      endForEach

      native "#undef ROGUE_ARG_PUSH"
      native "ffi_type * ret_type = &ffi_type_void;"

      local rt = m.return_type
      local ret_func = this=>_ret_undefined : (Function(IntPtr)->Value)
      block
        if (rt is null)
          escapeBlock
        endIf

        which (rt.name)
          case "Real64"
            native "ret_type = &ffi_type_double;"
            ret_func = this=>_ret_Real64
          case "Real32"
            native "ret_type = &ffi_type_float;"
            ret_func = this=>_ret_Real32
          case "Int64"
            native "ret_type = &ffi_type_sint64;"
            ret_func = this=>_ret_Int64
          case "Int32"
            native "ret_type = &ffi_type_sint32;"
            ret_func = this=>_ret_Int32
          case "Character"
            native "ret_type = &ffi_type_sint32;"
            ret_func = this=>_ret_Character
          case "Byte"
            native "ret_type = &ffi_type_uint8;"
            ret_func = this=>_ret_Byte
          case "Logical"
            block
              local c : Logical
              native @|static_assert(sizeof($c) == 4 || sizeof($c) == 8 || sizeof($c) == 1, "Logicals are of unhandled size on this platform");
                      |if (sizeof($c) == 4) {
                      |  ret_type = &ffi_type_sint32;
                      |} else if (sizeof($c) == 8) {
                      |  ret_type = &ffi_type_sint64;
                      |} else {
                      |  ret_type = &ffi_type_sint8;
                      |}
            endBlock
            ret_func = this=>_ret_Logical
          case "String"
            native "ret_type = &ffi_type_pointer;"
            ret_func = this=>_ret_String
          others
            if (rt.is_reference)
              native "ret_type = &ffi_type_pointer;"
              ret_func = this=>_ret_Object
              escapeBlock
            endIf
            throw NoMatchingMethodError("Return type is of unhandled type $" (rt.name))
        endWhich
      endBlock

      local failed = false
      native @|ffi_status s = ffi_prep_cif(&cif, FFI_DEFAULT_ABI, $args->count + 1, ret_type, types);
              |if (s != FFI_OK) $failed = 1;
      if (failed) throw NoMatchingMethodError("CIF creation failed")

      # Should (or can) we cache the cif?
      local fn_ptr = m.fn_ptr

      native "ffi_call (&cif, (void(*)())$fn_ptr, r_buf, cargs);"
      return ret_func(r_buf_ptr)
$endIf

  method _check_param (index:Int32, ptype:TypeInfo, condition:Logical)
    if (not condition)
      throw NoMatchingMethodError("Argument $ is incompatible with paramter type $" (index+1, ptype))
    endIf
endClass


class ValueTypeIntrospector<<$ValueType>> : Introspector
  PROPERTIES
    value_context : $ValueType

  METHODS
    method init( value_context )
      address = native( "(RogueInt64)(intptr_t)&$value_context" )->Int64
      info = value_context.type_info

    method to->Value
      #if (info.is_compound) return prior.to_Value
      #else                  return Value( value_context )
      if (info.is_compound) return Value( value_context->Object )
      else                  return Value( value_context )
endClass


class CompoundIntrospection<<$ValueType>> [aspect]
  METHODS
    method get_property( name:String )->Value [nonAPI]
      return introspector[ name ]

    method get_property<<$PropertyType>>( name:String )->$PropertyType
      forEach (i in 0..<property_count)
        if (property_name(i) == name)
          local type_index = this.type_info.index
          return native( "*(($($PropertyType)*)(((RogueByte*)&$this) + Rogue_types[$type_index].property_offsets[$i]))" )->$PropertyType
        endIf
      endForEach

      local default_value : $PropertyType
      return default_value

    method introspector->Introspector
      return ValueTypeIntrospector<<$ValueType>>( this )

    method property_count->Int32
      return type_info.properties.count

    method property_name( index:Int32 )->String
      return type_info.properties[ index ].name

    method set_property( name:String, value:Value )->this [nonAPI]
      introspector.set( name, value )
      return this

    method set_property<<$PropertyType>>( name:String, value:$PropertyType )->this
      forEach (i in 0..<property_count)
        if (property_name(i) == name)
          local type_index = this.type_info.index
          native( "*(($($PropertyType)*)(((RogueByte*)&$this) + Rogue_types[$type_index].property_offsets[$i])) = $value;" )
          return this
        endIf
      endForEach

      return this

    method to->Value
      return introspector->Value
endClass


class NoMatchingMethodError : Exception
endClass
